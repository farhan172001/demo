@Component
public class MQMessageConverter {

    // Most common MQ encodings (EBCDIC first)
    private static final String[] CHARSETS = {
            "Cp500",    // CCSID 500 (mainframe default)
            "Cp037",    // CCSID 37 (US EBCDIC)
            "Cp1047",   // EBCDIC Latin-1
            "ISO-8859-1",
            "Cp1252",
            "UTF-8"
    };

    public String decodeMessage(byte[] messageBytes) {
        String best = null;
        int bestScore = -1;

        for (String charset : CHARSETS) {
            try {
                if (!Charset.isSupported(charset)) continue;

                String decoded = new String(messageBytes, charset);
                int score = scoreReadable(decoded);

                if (score > bestScore) {
                    bestScore = score;
                    best = decoded;
                }

            } catch (Exception ignored) {}
        }

        // fallback (should not happen)
        return best != null ? best : new String(messageBytes);
    }

    // simple heuristic to choose best readable text
    private int scoreReadable(String text) {
        int score = 0;
        for (char c : text.toCharArray()) {
            if (Character.isLetterOrDigit(c) ||
                Character.isWhitespace(c) ||
                (c >= 32 && c <= 126)) {
                score++;
            }
        }
        return score;
    }
}


@RestController
@RequestMapping("/mq")
public class MQController {

    private final MQMessageConverter converter;

    public MQController(MQMessageConverter converter) {
        this.converter = converter;
    }

    @PostMapping("/convert")
    public ResponseEntity<String> convertFile(@RequestParam("file") MultipartFile file) {
        try {
            // Read raw bytes exactly as they are
            byte[] fileBytes = file.getBytes();

            // Decode using EBCDIC-aware converter
            String result = converter.decodeMessage(fileBytes);

            return ResponseEntity.ok(result);

        } catch (Exception e) {
            return ResponseEntity.status(500)
                    .body("Error processing file: " + e.getMessage());
        }
    }
}


@Component
public class MQMessageConverter {

    public String convert(byte[] input) {

        try {
            // 1) Check if binary is zlib compressed (0x78 = all zlib variants)
            if (input.length > 2 && (input[0] & 0xFF) == 0x78) {
                byte[] decompressed = decompress(input);

                // 2) Check if decompressed is PDF
                if (new String(decompressed, 0, 4).equals("%PDF")) {
                    return "PDF FILE DETECTED (binary) â€“ cannot display text.";
                }

                // 3) Try decode as UTF-8
                return new String(decompressed, StandardCharsets.UTF_8);
            }

            // If not compressed, return hex so user can see binary content
            return bytesToHex(input);

        } catch (Exception e) {
            return "Error decoding binary MQ message: " + e.getMessage();
        }
    }

    private byte[] decompress(byte[] input) throws IOException {
        InflaterInputStream inflater = new InflaterInputStream(new ByteArrayInputStream(input));
        return inflater.readAllBytes();
    }

    private String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) sb.append(String.format("%02X ", b));
        return sb.toString();
    }
}





