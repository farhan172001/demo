noimport com.ibm.msg.client.jakarta.wmq.WMQConstants;
import com.ibm.msg.client.jakarta.jms.JmsConnectionFactory;
import com.ibm.msg.client.jakarta.jms.JmsFactoryFactory;
import jakarta.jms.ConnectionFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Configuration
public class MQConfig {
    
    private static final Logger log = LoggerFactory.getLogger(MQConfig.class);
    
    @Value("${ibm.mq.host}")
    private String host;
    
    @Value("${ibm.mq.port}")
    private int port;
    
    @Value("${ibm.mq.channel}")
    private String channel;
    
    @Value("${ibm.mq.queueManager}")
    private String queueManager;
    
    @Value("${ibm.mq.user}")
    private String user;
    
    @Value("${ibm.mq.password}")
    private String password;

    @Bean
    public ConnectionFactory customMqConnectionFactory() throws Exception {
        log.info("Initializing Custom MQ Connection Factory");
        
        JmsFactoryFactory ff = JmsFactoryFactory.getInstance(WMQConstants.JAKARTA_WMQ_PROVIDER);
        JmsConnectionFactory cf = ff.createConnectionFactory();
        
        // Basic Connection Properties
        cf.setStringProperty(WMQConstants.WMQ_HOST_NAME, host);
        cf.setIntProperty(WMQConstants.WMQ_PORT, port);
        cf.setStringProperty(WMQConstants.WMQ_CHANNEL, channel);
        cf.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManager);
        cf.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT);
        
        // Credentials
        cf.setStringProperty(WMQConstants.USERID, user);
        cf.setStringProperty(WMQConstants.PASSWORD, password);
        cf.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false);
        
        // ====================================================================
        // CRITICAL: EBCDIC Encoding Configuration for Mainframe Messages
        // ====================================================================
        
        // Set Character Set to IBM500 (EBCDIC)
        // This matches: JMS_IBM_Character_Set: IBM500
        cf.setIntProperty(WMQConstants.WMQ_CCSID, 500);
        
        // Set Encoding to match mainframe
        // This matches: JMS_IBM_Encoding: 785
        cf.setIntProperty(WMQConstants.WMQ_ENCODING, 785);
        
        // Enable automatic message format conversion
        // This tells MQ client to convert EBCDIC to Unicode automatically
        cf.setIntProperty(WMQConstants.JMS_IBM_CHARACTER_SET, 500);
        cf.setIntProperty(WMQConstants.JMS_IBM_ENCODING, 785);
        
        // Target Client - for compatibility with mainframe messages
        cf.setIntProperty(WMQConstants.WMQ_TARGET_CLIENT, WMQConstants.WMQ_TARGET_DEST_MQ);
        
        // Message body format - indicates string format
        cf.setStringProperty(WMQConstants.WMQ_MSG_FORMAT, WMQConstants.MQFMT_STRING);
        
        log.info("MQ Connection Factory configured:");
        log.info("  Host: {}:{}", host, port);
        log.info("  Queue Manager: {}", queueManager);
        log.info("  Channel: {}", channel);
        log.info("  User: {}", user);
        log.info("  CCSID: 500 (IBM500 EBCDIC)");
        log.info("  Encoding: 785");
        
        return cf;
    }

    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() throws Exception {
        log.info("Initializing JMS Listener Container Factory");
        
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(customMqConnectionFactory());
        
        // Enable transactional session
        factory.setSessionTransacted(true);
        
        // Concurrency: min-max consumers (adjust to your throughput)
        factory.setConcurrency("1-5");
        
        // Error Handler
        factory.setErrorHandler(throwable -> 
            log.error("JMS Listener error occurred", throwable)
        );
        
        // Session acknowledgement mode (not needed with transactions, but good to be explicit)
        // factory.setSessionAcknowledgeMode(Session.CLIENT_ACKNOWLEDGE);
        
        log.info("JMS Listener Container Factory configured:");
        log.info("  Session Transacted: true");
        log.info("  Concurrency: 1-5");
        
        return factory;
    }
}






import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;

import javax.jms.JMSException;
import javax.jms.TextMessage;
import javax.jms.Message;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.UUID;

@Component
public class MQMessageReceiver {
    
    private static final Logger log = LoggerFactory.getLogger(MQMessageReceiver.class);
    private static final Charset IBM500_CHARSET = Charset.forName("IBM500");
    
    @Value("${app.file.output.data.path}")
    private String dataFilePath;
    
    @Value("${app.file.output.metadata.path}")
    private String metadataFilePath;
    
    @Value("${app.metadata.splitter:@}")
    private String metadataSplitter;
    
    @Value("${app.file.type:PDF}")
    private String fileType;
    
    private int messageCounter = 0;

    /**
     * CORRECT WAY for JMS TextMessage with EBCDIC encoding
     * The message is TextMessage but contains EBCDIC-encoded content with binary data
     */
    @JmsListener(destination = "${app.ibm.mq.queue}")
    public void receiveMessage(Message message) {
        try {
            log.info("Received JMS Message");
            log.info("Message Type: {}", message.getClass().getSimpleName());
            
            // Log important properties
            logMessageProperties(message);
            
            if (message instanceof TextMessage) {
                processTextMessage((TextMessage) message);
            } else {
                log.warn("Unexpected message type: {}", message.getClass().getName());
            }
            
        } catch (JMSException e) {
            log.error("JMS Error processing message: {}", e.getMessage(), e);
        } catch (Exception e) {
            log.error("Error processing MQ message: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Process TextMessage with EBCDIC encoding
     */
    private void processTextMessage(TextMessage textMessage) throws JMSException {
        // Get the text content (already converted by MQ client from EBCDIC to Java String)
        String messageText = textMessage.getText();
        
        if (messageText == null || messageText.isEmpty()) {
            log.warn("Message is empty");
            return;
        }
        
        log.info("Message length: {} characters", messageText.length());
        log.info("First 100 chars: {}", 
            messageText.length() > 100 ? messageText.substring(0, 100) : messageText);
        
        // The text might still need to be converted back to bytes and re-interpreted
        // because MQ converted EBCDIC to Unicode but the content is binary (PDF)
        
        // Option 1: If the content is Base64 encoded
        if (isBase64Encoded(messageText)) {
            processBase64EncodedMessage(messageText);
        } 
        // Option 2: If content needs EBCDIC re-interpretation
        else {
            processEbcdicBinaryMessage(messageText);
        }
    }
    
    /**
     * Check if the message is Base64 encoded
     */
    private boolean isBase64Encoded(String text) {
        // Simple heuristic: Base64 uses only A-Z, a-z, 0-9, +, /, =
        return text.matches("^[A-Za-z0-9+/=]+$");
    }
    
    /**
     * Process Base64 encoded message
     */
    private void processBase64EncodedMessage(String base64Content) {
        try {
            log.info("Processing Base64 encoded message");
            
            // Decode Base64
            byte[] decodedBytes = Base64.getDecoder().decode(base64Content);
            log.info("Decoded byte array length: {}", decodedBytes.length);
            
            // Extract metadata and binary content
            processDecodedContent(decodedBytes);
            
        } catch (Exception e) {
            log.error("Error processing Base64 message: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Process EBCDIC binary message (re-convert to bytes)
     */
    private void processEbcdicBinaryMessage(String messageText) {
        try {
            log.info("Processing EBCDIC binary message");
            
            // Convert the Java String back to bytes using the original encoding
            // The MQ client converted EBCDIC->Unicode, we need to reverse this
            byte[] messageBytes = messageText.getBytes(IBM500_CHARSET);
            log.info("Converted to byte array length: {}", messageBytes.length);
            
            // Extract metadata and binary content
            processDecodedContent(messageBytes);
            
        } catch (Exception e) {
            log.error("Error processing EBCDIC message: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Process the decoded byte content
     * This extracts metadata and creates the two files
     */
    private void processDecodedContent(byte[] contentBytes) {
        try {
            // Skip first 32 bytes header (as per legacy code)
            int headerSize = 32;
            if (contentBytes.length <= headerSize) {
                log.warn("Content too short. Length: {}", contentBytes.length);
                return;
            }
            
            // Extract payload without header
            byte[] payloadWithoutHeader = new byte[contentBytes.length - headerSize];
            System.arraycopy(contentBytes, headerSize, payloadWithoutHeader, 0, payloadWithoutHeader.length);
            
            log.info("Payload length after removing header: {} bytes", payloadWithoutHeader.length);
            
            // Convert payload to EBCDIC string to extract metadata
            String payloadAsEbcdicString = new String(payloadWithoutHeader, IBM500_CHARSET);
            
            // Split to separate metadata from binary content
            String[] metadataArray = payloadAsEbcdicString.split(metadataSplitter);
            
            // Extract metadata (skip first element, concatenate rest)
            StringBuilder metadata = new StringBuilder();
            if (metadataArray != null && metadataArray.length > 1) {
                for (int i = 1; i < metadataArray.length; i++) {
                    metadata.append(metadataArray[i]);
                    if (i < metadataArray.length - 1) {
                        metadata.append(System.lineSeparator());
                    }
                }
            }
            
            String metadataContent = metadata.toString().trim();
            log.info("Extracted metadata length: {} characters", metadataContent.length());
            log.info("Metadata preview: {}", 
                metadataContent.length() > 200 
                    ? metadataContent.substring(0, 200) + "..." 
                    : metadataContent);
            
            // Generate unique filenames
            String uniqueId = UUID.randomUUID().toString().substring(0, 8);
            messageCounter++;
            
            String fileExtension = fileType.equalsIgnoreCase("TIFF") ? ".tif" : ".pdf";
            String dataFileName = String.format("data_%s_%d%s", uniqueId, messageCounter, fileExtension);
            String metadataFileName = String.format("metadata_%s_%d.txt", uniqueId, messageCounter);
            
            // Create the two files
            boolean success = createFiles(
                payloadWithoutHeader, 
                metadataContent,
                dataFileName,
                metadataFileName
            );
            
            if (success) {
                log.info("âœ“ Successfully created files: {} and {}", dataFileName, metadataFileName);
            } else {
                log.error("âœ— Failed to create files");
            }
            
        } catch (Exception e) {
            log.error("Error processing decoded content: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Creates two files:
     * 1. Data file (PDF/TIFF) - binary content
     * 2. Metadata file - human-readable text
     */
    private boolean createFiles(
            byte[] binaryContent,
            String metadata,
            String dataFileName,
            String metadataFileName) {
        
        File dataFile = null;
        File metadataFile = null;
        
        try {
            // Create data file (PDF/TIFF)
            String dataFileFullPath = dataFilePath + File.separator + dataFileName;
            dataFile = new File(dataFileFullPath);
            dataFile.getParentFile().mkdirs();
            
            try (FileOutputStream fos = new FileOutputStream(dataFile)) {
                fos.write(binaryContent);
                fos.flush();
            }
            
            log.info("Created data file: {}", dataFileFullPath);
            log.info("Data file size: {} bytes", dataFile.length());
            
            // Validate PDF/TIFF header
            validateFileHeader(binaryContent, fileType);
            
            // Create metadata file (human-readable text)
            String metadataFileFullPath = metadataFilePath + File.separator + metadataFileName;
            metadataFile = new File(metadataFileFullPath);
            metadataFile.getParentFile().mkdirs();
            
            try (FileOutputStream fos = new FileOutputStream(metadataFile)) {
                // Write metadata as UTF-8 text (human-readable)
                fos.write(metadata.getBytes(StandardCharsets.UTF_8));
                fos.flush();
            }
            
            log.info("Created metadata file: {}", metadataFileFullPath);
            log.info("Metadata file size: {} bytes", metadataFile.length());
            
            return true;
            
        } catch (IOException e) {
            log.error("Error creating files: {}", e.getMessage(), e);
            
            // Cleanup on failure
            if (dataFile != null && dataFile.exists()) {
                dataFile.delete();
            }
            if (metadataFile != null && metadataFile.exists()) {
                metadataFile.delete();
            }
            
            return false;
        }
    }
    
    /**
     * Validate file header to ensure it's correct format
     */
    private void validateFileHeader(byte[] content, String expectedType) {
        if (content.length < 4) {
            log.warn("Content too short to validate header");
            return;
        }
        
        // PDF signature: %PDF (0x25 0x50 0x44 0x46)
        if (expectedType.equalsIgnoreCase("PDF")) {
            if (content[0] == 0x25 && content[1] == 0x50 && 
                content[2] == 0x44 && content[3] == 0x46) {
                log.info("âœ“ Valid PDF header detected");
            } else {
                log.warn("âš  PDF header not detected. First 4 bytes: {} {} {} {}", 
                    String.format("0x%02X", content[0]),
                    String.format("0x%02X", content[1]),
                    String.format("0x%02X", content[2]),
                    String.format("0x%02X", content[3]));
            }
        }
        
        // TIFF signature: II* or MM* (0x49 0x49 0x2A 0x00 or 0x4D 0x4D 0x00 0x2A)
        if (expectedType.equalsIgnoreCase("TIFF")) {
            if ((content[0] == 0x49 && content[1] == 0x49 && content[2] == 0x2A) ||
                (content[0] == 0x4D && content[1] == 0x4D && content[3] == 0x2A)) {
                log.info("âœ“ Valid TIFF header detected");
            } else {
                log.warn("âš  TIFF header not detected");
            }
        }
    }
    
    /**
     * Log message properties for debugging
     */
    private void logMessageProperties(Message message) throws JMSException {
        log.info("JMS Properties:");
        log.info("  JMSMessageID: {}", message.getJMSMessageID());
        log.info("  JMSTimestamp: {}", message.getJMSTimestamp());
        log.info("  JMSCorrelationID: {}", message.getJMSCorrelationID());
        
        // IBM MQ specific properties
        try {
            log.info("  JMS_IBM_Character_Set: {}", 
                message.getStringProperty("JMS_IBM_Character_Set"));
            log.info("  JMS_IBM_Encoding: {}", 
                message.getIntProperty("JMS_IBM_Encoding"));
            log.info("  JMS_IBM_Format: {}", 
                message.getStringProperty("JMS_IBM_Format"));
            log.info("  JMSXAppID: {}", 
                message.getStringProperty("JMSXAppID"));
        } catch (JMSException e) {
            log.debug("Could not read IBM MQ properties: {}", e.getMessage());
        }
    }
}




app.file.output.data.path=${OUTPUT_DATA_PATH:/output/data}
app.file.output.metadata.path=${OUTPUT_METADATA_PATH:/output/metadata}

app.metadata.splitter=@

app.file.type=PDF





// ============================================================================
// FileConversionController.java
// ============================================================================
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.util.Map;

@RestController
@RequestMapping("/api/convert")
public class FileConversionController {
    
    @Autowired
    private FileConversionService conversionService;
    
    /**
     * Test endpoint to convert uploaded .txt file
     * POST http://localhost:8080/api/convert/test
     */
    @PostMapping("/test")
    public ResponseEntity<Map<String, Object>> testConversion(
            @RequestParam("file") MultipartFile file,
            @RequestParam(value = "skipHeader", defaultValue = "true") boolean skipHeader,
            @RequestParam(value = "headerSize", defaultValue = "32") int headerSize,
            @RequestParam(value = "metadataSplitter", defaultValue = "@") String metadataSplitter) {
        
        try {
            Map<String, Object> result = conversionService.convertFile(
                file, skipHeader, headerSize, metadataSplitter);
            
            return ResponseEntity.ok(result);
            
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of(
                    "error", e.getMessage(),
                    "success", false
                ));
        }
    }
    
    /**
     * Download the converted PDF file
     * GET http://localhost:8080/api/convert/download/pdf
     */
    @GetMapping("/download/pdf")
    public ResponseEntity<byte[]> downloadPdf() {
        try {
            byte[] pdfBytes = conversionService.getLastConvertedPdf();
            
            if (pdfBytes == null) {
                return ResponseEntity.notFound().build();
            }
            
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_PDF);
            headers.setContentDispositionFormData("attachment", "converted.pdf");
            
            return ResponseEntity.ok()
                .headers(headers)
                .body(pdfBytes);
                
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
    
    /**
     * Download the converted metadata file
     * GET http://localhost:8080/api/convert/download/metadata
     */
    @GetMapping("/download/metadata")
    public ResponseEntity<String> downloadMetadata() {
        try {
            String metadata = conversionService.getLastConvertedMetadata();
            
            if (metadata == null) {
                return ResponseEntity.notFound().build();
            }
            
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.TEXT_PLAIN);
            headers.setContentDispositionFormData("attachment", "metadata.txt");
            
            return ResponseEntity.ok()
                .headers(headers)
                .body(metadata);
                
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}

// ============================================================================
// FileConversionService.java
// ============================================================================
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

@Service
public class FileConversionService {
    
    private static final Logger log = LoggerFactory.getLogger(FileConversionService.class);
    private static final Charset IBM500_CHARSET = Charset.forName("IBM500");
    
    // Store last converted files for download
    private byte[] lastPdfBytes;
    private String lastMetadata;
    
    /**
     * Convert the uploaded .txt file (which contains garbled EBCDIC text)
     * back to proper PDF and metadata
     */
    public Map<String, Object> convertFile(
            MultipartFile file,
            boolean skipHeader,
            int headerSize,
            String metadataSplitter) throws IOException {
        
        log.info("Starting file conversion for: {}", file.getOriginalFilename());
        
        Map<String, Object> result = new HashMap<>();
        
        try {
            // Step 1: Read the uploaded file as bytes
            byte[] fileBytes = file.getBytes();
            log.info("Original file size: {} bytes", fileBytes.length);
            
            // Step 2: Convert to String using UTF-8 (this is how it was saved)
            String contentAsUtf8 = new String(fileBytes, StandardCharsets.UTF_8);
            log.info("Content as UTF-8 string length: {} chars", contentAsUtf8.length());
            log.info("First 100 chars (UTF-8): {}", 
                contentAsUtf8.length() > 100 ? contentAsUtf8.substring(0, 100) : contentAsUtf8);
            
            // Step 3: Convert the UTF-8 string back to bytes using IBM500
            // This reverses the incorrect encoding that happened when saving as String
            byte[] contentBytes = contentAsUtf8.getBytes(IBM500_CHARSET);
            log.info("Content as IBM500 bytes length: {} bytes", contentBytes.length);
            
            // Step 4: Skip header if needed (first 32 bytes in original message)
            byte[] payload;
            if (skipHeader && contentBytes.length > headerSize) {
                payload = Arrays.copyOfRange(contentBytes, headerSize, contentBytes.length);
                log.info("Payload after removing {} byte header: {} bytes", headerSize, payload.length);
            } else {
                payload = contentBytes;
                log.info("No header removed, using full content");
            }
            
            // Step 5: Check PDF header
            String pdfHeaderCheck = checkPdfHeader(payload);
            log.info("PDF header check: {}", pdfHeaderCheck);
            result.put("pdfHeaderCheck", pdfHeaderCheck);
            
            // Step 6: Try to extract metadata
            String payloadAsEbcdicString = new String(payload, IBM500_CHARSET);
            String[] metadataArray = payloadAsEbcdicString.split(metadataSplitter);
            
            StringBuilder metadata = new StringBuilder();
            if (metadataArray != null && metadataArray.length > 1) {
                log.info("Found {} metadata segments", metadataArray.length);
                for (int i = 1; i < metadataArray.length; i++) {
                    metadata.append(metadataArray[i]);
                    if (i < metadataArray.length - 1) {
                        metadata.append(System.lineSeparator());
                    }
                }
            } else {
                log.warn("No metadata found using splitter: '{}'", metadataSplitter);
            }
            
            String metadataContent = metadata.toString().trim();
            log.info("Extracted metadata length: {} chars", metadataContent.length());
            
            // Store for download
            lastPdfBytes = payload;
            lastMetadata = metadataContent;
            
            // Build result
            result.put("success", true);
            result.put("originalFileSize", fileBytes.length);
            result.put("payloadSize", payload.length);
            result.put("metadataLength", metadataContent.length);
            result.put("metadataPreview", metadataContent.length() > 200 
                ? metadataContent.substring(0, 200) + "..." 
                : metadataContent);
            result.put("pdfDownloadUrl", "/api/convert/download/pdf");
            result.put("metadataDownloadUrl", "/api/convert/download/metadata");
            
            // Hex dump of first 50 bytes for debugging
            result.put("first50BytesHex", bytesToHex(payload, 50));
            
            return result;
            
        } catch (Exception e) {
            log.error("Error during conversion: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Check if the payload starts with PDF header
     */
    private String checkPdfHeader(byte[] payload) {
        if (payload.length < 4) {
            return "Payload too short (< 4 bytes)";
        }
        
        // PDF signature: %PDF (0x25 0x50 0x44 0x46)
        if (payload[0] == 0x25 && payload[1] == 0x50 && 
            payload[2] == 0x44 && payload[3] == 0x46) {
            return "âœ“ Valid PDF header found (%PDF)";
        } else {
            return String.format("âš  PDF header NOT found. First 4 bytes: 0x%02X 0x%02X 0x%02X 0x%02X",
                payload[0], payload[1], payload[2], payload[3]);
        }
    }
    
    /**
     * Convert bytes to hex string for debugging
     */
    private String bytesToHex(byte[] bytes, int limit) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < Math.min(bytes.length, limit); i++) {
            sb.append(String.format("%02X ", bytes[i]));
            if ((i + 1) % 16 == 0) {
                sb.append("\n");
            }
        }
        return sb.toString();
    }
    
    public byte[] getLastConvertedPdf() {
        return lastPdfBytes;
    }
    
    public String getLastConvertedMetadata() {
        return lastMetadata;
    }
}

// ============================================================================
// HTML Test Page (save as src/main/resources/static/test-converter.html)
// ============================================================================
/*
<!DOCTYPE html>
<html>
<head>
    <title>EBCDIC File Converter Test</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .container { max-width: 800px; margin: 0 auto; }
        .upload-section { border: 2px dashed #ccc; padding: 30px; text-align: center; margin: 20px 0; }
        .result-section { margin: 20px 0; padding: 20px; background: #f5f5f5; border-radius: 5px; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        pre { background: #fff; padding: 10px; overflow-x: auto; border: 1px solid #ddd; }
        .success { color: green; }
        .error { color: red; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ”§ EBCDIC to PDF Converter Test</h1>
        
        <div class="upload-section">
            <h2>Upload your saved .txt file</h2>
            <input type="file" id="fileInput" accept=".txt">
            <br><br>
            
            <label>
                <input type="checkbox" id="skipHeader" checked> Skip first 32 bytes (header)
            </label>
            <br>
            
            <label>
                Metadata Splitter: <input type="text" id="splitter" value="@" size="5">
            </label>
            <br><br>
            
            <button onclick="convertFile()">Convert File</button>
        </div>
        
        <div id="results" class="result-section" style="display:none;">
            <h2>Conversion Results</h2>
            <div id="resultContent"></div>
        </div>
    </div>
    
    <script>
        async function convertFile() {
            const fileInput = document.getElementById('fileInput');
            const skipHeader = document.getElementById('skipHeader').checked;
            const splitter = document.getElementById('splitter').value;
            
            if (!fileInput.files.length) {
                alert('Please select a file first');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', fileInput.files[0]);
            formData.append('skipHeader', skipHeader);
            formData.append('metadataSplitter', splitter);
            
            try {
                const response = await fetch('/api/convert/test', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                displayResults(result);
            } catch (error) {
                alert('Error: ' + error.message);
            }
        }
        
        function displayResults(result) {
            const resultsDiv = document.getElementById('results');
            const contentDiv = document.getElementById('resultContent');
            
            let html = '';
            
            if (result.success) {
                html += '<p class="success">âœ“ Conversion successful!</p>';
                html += '<p><strong>Original file size:</strong> ' + result.originalFileSize + ' bytes</p>';
                html += '<p><strong>Payload size:</strong> ' + result.payloadSize + ' bytes</p>';
                html += '<p><strong>PDF Header Check:</strong> ' + result.pdfHeaderCheck + '</p>';
                html += '<p><strong>Metadata length:</strong> ' + result.metadataLength + ' characters</p>';
                
                if (result.metadataPreview) {
                    html += '<h3>Metadata Preview:</h3>';
                    html += '<pre>' + result.metadataPreview + '</pre>';
                }
                
                html += '<h3>First 50 Bytes (Hex):</h3>';
                html += '<pre>' + result.first50BytesHex + '</pre>';
                
                html += '<br>';
                html += '<button onclick="downloadFile(\'/api/convert/download/pdf\', \'converted.pdf\')">Download PDF</button>';
                html += '<button onclick="downloadFile(\'/api/convert/download/metadata\', \'metadata.txt\')">Download Metadata</button>';
            } else {
                html += '<p class="error">âœ— Conversion failed: ' + result.error + '</p>';
            }
            
            contentDiv.innerHTML = html;
            resultsDiv.style.display = 'block';
        }
        
        function downloadFile(url, filename) {
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
    </script>
</body>
</html>
*/
