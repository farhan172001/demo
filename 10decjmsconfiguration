import com.ibm.msg.client.jakarta.wmq.WMQConstants;
import com.ibm.msg.client.jakarta.jms.JmsConnectionFactory;
import com.ibm.msg.client.jakarta.jms.JmsFactoryFactory;
import jakarta.jms.ConnectionFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jms.config.DefaultJmsListenerContainerFactory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@Configuration
public class MQConfig {
    
    private static final Logger log = LoggerFactory.getLogger(MQConfig.class);
    
    @Value("${ibm.mq.host}")
    private String host;
    
    @Value("${ibm.mq.port}")
    private int port;
    
    @Value("${ibm.mq.channel}")
    private String channel;
    
    @Value("${ibm.mq.queueManager}")
    private String queueManager;
    
    @Value("${ibm.mq.user}")
    private String user;
    
    @Value("${ibm.mq.password}")
    private String password;

    @Bean
    public ConnectionFactory customMqConnectionFactory() throws Exception {
        log.info("Initializing Custom MQ Connection Factory");
        
        JmsFactoryFactory ff = JmsFactoryFactory.getInstance(WMQConstants.JAKARTA_WMQ_PROVIDER);
        JmsConnectionFactory cf = ff.createConnectionFactory();
        
        // Basic Connection Properties
        cf.setStringProperty(WMQConstants.WMQ_HOST_NAME, host);
        cf.setIntProperty(WMQConstants.WMQ_PORT, port);
        cf.setStringProperty(WMQConstants.WMQ_CHANNEL, channel);
        cf.setStringProperty(WMQConstants.WMQ_QUEUE_MANAGER, queueManager);
        cf.setIntProperty(WMQConstants.WMQ_CONNECTION_MODE, WMQConstants.WMQ_CM_CLIENT);
        
        // Credentials
        cf.setStringProperty(WMQConstants.USERID, user);
        cf.setStringProperty(WMQConstants.PASSWORD, password);
        cf.setBooleanProperty(WMQConstants.USER_AUTHENTICATION_MQCSP, false);
        
        // ====================================================================
        // CRITICAL: EBCDIC Encoding Configuration for Mainframe Messages
        // ====================================================================
        
        // Set Character Set to IBM500 (EBCDIC)
        // This matches: JMS_IBM_Character_Set: IBM500
        cf.setIntProperty(WMQConstants.WMQ_CCSID, 500);
        
        // Set Encoding to match mainframe
        // This matches: JMS_IBM_Encoding: 785
        cf.setIntProperty(WMQConstants.WMQ_ENCODING, 785);
        
        // Enable automatic message format conversion
        // This tells MQ client to convert EBCDIC to Unicode automatically
        cf.setIntProperty(WMQConstants.JMS_IBM_CHARACTER_SET, 500);
        cf.setIntProperty(WMQConstants.JMS_IBM_ENCODING, 785);
        
        // Target Client - for compatibility with mainframe messages
        cf.setIntProperty(WMQConstants.WMQ_TARGET_CLIENT, WMQConstants.WMQ_TARGET_DEST_MQ);
        
        // Message body format - indicates string format
        cf.setStringProperty(WMQConstants.WMQ_MSG_FORMAT, WMQConstants.MQFMT_STRING);
        
        log.info("MQ Connection Factory configured:");
        log.info("  Host: {}:{}", host, port);
        log.info("  Queue Manager: {}", queueManager);
        log.info("  Channel: {}", channel);
        log.info("  User: {}", user);
        log.info("  CCSID: 500 (IBM500 EBCDIC)");
        log.info("  Encoding: 785");
        
        return cf;
    }

    @Bean
    public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() throws Exception {
        log.info("Initializing JMS Listener Container Factory");
        
        DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory();
        factory.setConnectionFactory(customMqConnectionFactory());
        
        // Enable transactional session
        factory.setSessionTransacted(true);
        
        // Concurrency: min-max consumers (adjust to your throughput)
        factory.setConcurrency("1-5");
        
        // Error Handler
        factory.setErrorHandler(throwable -> 
            log.error("JMS Listener error occurred", throwable)
        );
        
        // Session acknowledgement mode (not needed with transactions, but good to be explicit)
        // factory.setSessionAcknowledgeMode(Session.CLIENT_ACKNOWLEDGE);
        
        log.info("JMS Listener Container Factory configured:");
        log.info("  Session Transacted: true");
        log.info("  Concurrency: 1-5");
        
        return factory;
    }
}






import org.springframework.jms.annotation.JmsListener;
import org.springframework.stereotype.Component;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;

import javax.jms.JMSException;
import javax.jms.TextMessage;
import javax.jms.Message;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.UUID;

@Component
public class MQMessageReceiver {
    
    private static final Logger log = LoggerFactory.getLogger(MQMessageReceiver.class);
    private static final Charset IBM500_CHARSET = Charset.forName("IBM500");
    
    @Value("${app.file.output.data.path}")
    private String dataFilePath;
    
    @Value("${app.file.output.metadata.path}")
    private String metadataFilePath;
    
    @Value("${app.metadata.splitter:@}")
    private String metadataSplitter;
    
    @Value("${app.file.type:PDF}")
    private String fileType;
    
    private int messageCounter = 0;

    /**
     * CORRECT WAY for JMS TextMessage with EBCDIC encoding
     * The message is TextMessage but contains EBCDIC-encoded content with binary data
     */
    @JmsListener(destination = "${app.ibm.mq.queue}")
    public void receiveMessage(Message message) {
        try {
            log.info("Received JMS Message");
            log.info("Message Type: {}", message.getClass().getSimpleName());
            
            // Log important properties
            logMessageProperties(message);
            
            if (message instanceof TextMessage) {
                processTextMessage((TextMessage) message);
            } else {
                log.warn("Unexpected message type: {}", message.getClass().getName());
            }
            
        } catch (JMSException e) {
            log.error("JMS Error processing message: {}", e.getMessage(), e);
        } catch (Exception e) {
            log.error("Error processing MQ message: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Process TextMessage with EBCDIC encoding
     */
    private void processTextMessage(TextMessage textMessage) throws JMSException {
        // Get the text content (already converted by MQ client from EBCDIC to Java String)
        String messageText = textMessage.getText();
        
        if (messageText == null || messageText.isEmpty()) {
            log.warn("Message is empty");
            return;
        }
        
        log.info("Message length: {} characters", messageText.length());
        log.info("First 100 chars: {}", 
            messageText.length() > 100 ? messageText.substring(0, 100) : messageText);
        
        // The text might still need to be converted back to bytes and re-interpreted
        // because MQ converted EBCDIC to Unicode but the content is binary (PDF)
        
        // Option 1: If the content is Base64 encoded
        if (isBase64Encoded(messageText)) {
            processBase64EncodedMessage(messageText);
        } 
        // Option 2: If content needs EBCDIC re-interpretation
        else {
            processEbcdicBinaryMessage(messageText);
        }
    }
    
    /**
     * Check if the message is Base64 encoded
     */
    private boolean isBase64Encoded(String text) {
        // Simple heuristic: Base64 uses only A-Z, a-z, 0-9, +, /, =
        return text.matches("^[A-Za-z0-9+/=]+$");
    }
    
    /**
     * Process Base64 encoded message
     */
    private void processBase64EncodedMessage(String base64Content) {
        try {
            log.info("Processing Base64 encoded message");
            
            // Decode Base64
            byte[] decodedBytes = Base64.getDecoder().decode(base64Content);
            log.info("Decoded byte array length: {}", decodedBytes.length);
            
            // Extract metadata and binary content
            processDecodedContent(decodedBytes);
            
        } catch (Exception e) {
            log.error("Error processing Base64 message: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Process EBCDIC binary message (re-convert to bytes)
     */
    private void processEbcdicBinaryMessage(String messageText) {
        try {
            log.info("Processing EBCDIC binary message");
            
            // Convert the Java String back to bytes using the original encoding
            // The MQ client converted EBCDIC->Unicode, we need to reverse this
            byte[] messageBytes = messageText.getBytes(IBM500_CHARSET);
            log.info("Converted to byte array length: {}", messageBytes.length);
            
            // Extract metadata and binary content
            processDecodedContent(messageBytes);
            
        } catch (Exception e) {
            log.error("Error processing EBCDIC message: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Process the decoded byte content
     * This extracts metadata and creates the two files
     */
    private void processDecodedContent(byte[] contentBytes) {
        try {
            // Skip first 32 bytes header (as per legacy code)
            int headerSize = 32;
            if (contentBytes.length <= headerSize) {
                log.warn("Content too short. Length: {}", contentBytes.length);
                return;
            }
            
            // Extract payload without header
            byte[] payloadWithoutHeader = new byte[contentBytes.length - headerSize];
            System.arraycopy(contentBytes, headerSize, payloadWithoutHeader, 0, payloadWithoutHeader.length);
            
            log.info("Payload length after removing header: {} bytes", payloadWithoutHeader.length);
            
            // Convert payload to EBCDIC string to extract metadata
            String payloadAsEbcdicString = new String(payloadWithoutHeader, IBM500_CHARSET);
            
            // Split to separate metadata from binary content
            String[] metadataArray = payloadAsEbcdicString.split(metadataSplitter);
            
            // Extract metadata (skip first element, concatenate rest)
            StringBuilder metadata = new StringBuilder();
            if (metadataArray != null && metadataArray.length > 1) {
                for (int i = 1; i < metadataArray.length; i++) {
                    metadata.append(metadataArray[i]);
                    if (i < metadataArray.length - 1) {
                        metadata.append(System.lineSeparator());
                    }
                }
            }
            
            String metadataContent = metadata.toString().trim();
            log.info("Extracted metadata length: {} characters", metadataContent.length());
            log.info("Metadata preview: {}", 
                metadataContent.length() > 200 
                    ? metadataContent.substring(0, 200) + "..." 
                    : metadataContent);
            
            // Generate unique filenames
            String uniqueId = UUID.randomUUID().toString().substring(0, 8);
            messageCounter++;
            
            String fileExtension = fileType.equalsIgnoreCase("TIFF") ? ".tif" : ".pdf";
            String dataFileName = String.format("data_%s_%d%s", uniqueId, messageCounter, fileExtension);
            String metadataFileName = String.format("metadata_%s_%d.txt", uniqueId, messageCounter);
            
            // Create the two files
            boolean success = createFiles(
                payloadWithoutHeader, 
                metadataContent,
                dataFileName,
                metadataFileName
            );
            
            if (success) {
                log.info("✓ Successfully created files: {} and {}", dataFileName, metadataFileName);
            } else {
                log.error("✗ Failed to create files");
            }
            
        } catch (Exception e) {
            log.error("Error processing decoded content: {}", e.getMessage(), e);
        }
    }
    
    /**
     * Creates two files:
     * 1. Data file (PDF/TIFF) - binary content
     * 2. Metadata file - human-readable text
     */
    private boolean createFiles(
            byte[] binaryContent,
            String metadata,
            String dataFileName,
            String metadataFileName) {
        
        File dataFile = null;
        File metadataFile = null;
        
        try {
            // Create data file (PDF/TIFF)
            String dataFileFullPath = dataFilePath + File.separator + dataFileName;
            dataFile = new File(dataFileFullPath);
            dataFile.getParentFile().mkdirs();
            
            try (FileOutputStream fos = new FileOutputStream(dataFile)) {
                fos.write(binaryContent);
                fos.flush();
            }
            
            log.info("Created data file: {}", dataFileFullPath);
            log.info("Data file size: {} bytes", dataFile.length());
            
            // Validate PDF/TIFF header
            validateFileHeader(binaryContent, fileType);
            
            // Create metadata file (human-readable text)
            String metadataFileFullPath = metadataFilePath + File.separator + metadataFileName;
            metadataFile = new File(metadataFileFullPath);
            metadataFile.getParentFile().mkdirs();
            
            try (FileOutputStream fos = new FileOutputStream(metadataFile)) {
                // Write metadata as UTF-8 text (human-readable)
                fos.write(metadata.getBytes(StandardCharsets.UTF_8));
                fos.flush();
            }
            
            log.info("Created metadata file: {}", metadataFileFullPath);
            log.info("Metadata file size: {} bytes", metadataFile.length());
            
            return true;
            
        } catch (IOException e) {
            log.error("Error creating files: {}", e.getMessage(), e);
            
            // Cleanup on failure
            if (dataFile != null && dataFile.exists()) {
                dataFile.delete();
            }
            if (metadataFile != null && metadataFile.exists()) {
                metadataFile.delete();
            }
            
            return false;
        }
    }
    
    /**
     * Validate file header to ensure it's correct format
     */
    private void validateFileHeader(byte[] content, String expectedType) {
        if (content.length < 4) {
            log.warn("Content too short to validate header");
            return;
        }
        
        // PDF signature: %PDF (0x25 0x50 0x44 0x46)
        if (expectedType.equalsIgnoreCase("PDF")) {
            if (content[0] == 0x25 && content[1] == 0x50 && 
                content[2] == 0x44 && content[3] == 0x46) {
                log.info("✓ Valid PDF header detected");
            } else {
                log.warn("⚠ PDF header not detected. First 4 bytes: {} {} {} {}", 
                    String.format("0x%02X", content[0]),
                    String.format("0x%02X", content[1]),
                    String.format("0x%02X", content[2]),
                    String.format("0x%02X", content[3]));
            }
        }
        
        // TIFF signature: II* or MM* (0x49 0x49 0x2A 0x00 or 0x4D 0x4D 0x00 0x2A)
        if (expectedType.equalsIgnoreCase("TIFF")) {
            if ((content[0] == 0x49 && content[1] == 0x49 && content[2] == 0x2A) ||
                (content[0] == 0x4D && content[1] == 0x4D && content[3] == 0x2A)) {
                log.info("✓ Valid TIFF header detected");
            } else {
                log.warn("⚠ TIFF header not detected");
            }
        }
    }
    
    /**
     * Log message properties for debugging
     */
    private void logMessageProperties(Message message) throws JMSException {
        log.info("JMS Properties:");
        log.info("  JMSMessageID: {}", message.getJMSMessageID());
        log.info("  JMSTimestamp: {}", message.getJMSTimestamp());
        log.info("  JMSCorrelationID: {}", message.getJMSCorrelationID());
        
        // IBM MQ specific properties
        try {
            log.info("  JMS_IBM_Character_Set: {}", 
                message.getStringProperty("JMS_IBM_Character_Set"));
            log.info("  JMS_IBM_Encoding: {}", 
                message.getIntProperty("JMS_IBM_Encoding"));
            log.info("  JMS_IBM_Format: {}", 
                message.getStringProperty("JMS_IBM_Format"));
            log.info("  JMSXAppID: {}", 
                message.getStringProperty("JMSXAppID"));
        } catch (JMSException e) {
            log.debug("Could not read IBM MQ properties: {}", e.getMessage());
        }
    }
}




app.file.output.data.path=${OUTPUT_DATA_PATH:/output/data}
app.file.output.metadata.path=${OUTPUT_METADATA_PATH:/output/metadata}

app.metadata.splitter=@

app.file.type=PDF
