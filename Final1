private String resolveContentType(String fileName) {
    String lower = fileName.toLowerCase();

    if (lower.endsWith(".pdf")) {
        return "application/pdf";
    }

    if (lower.endsWith(".txt")) {
        return "text/plain";
    }

    // default fallback
    return "application/octet-stream";
}
private String resolveContentType(String fileName) throws S3OperationException {
    String lower = fileName.toLowerCase();

    if (lower.endsWith(".pdf")) {
        return "application/pdf";
    }
    if (lower.endsWith(".txt")) {
        return "text/plain";
    }

    // ❌ Unsupported file type
    throw new S3OperationException(
            "Unsupported file format. Only PDF and TXT files are allowed: " + fileName
    );
}
@Component
public class FileConversionUtil {

    public byte[] convertBase64ToPdf(String base64) {
        return Base64.getDecoder().decode(base64);
    }

    public String getFileNameWithoutExtension(String fileName) {
        if (fileName == null) return "unknown";
        return fileName.replace(".pdf", "").replace(".PDF", "");
    }
}
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class MetadataModel {
    private String groupNumber;
    private String groupName;
    private String loggedAt;
}
@Component
public class MetadataParser {

    public MetadataModel parse(String txt) {

        MetadataModel.MetadataModelBuilder builder = MetadataModel.builder();

        String[] lines = txt.split("[;\n]");

        for (String line : lines) {
            if (line.contains("GroupNumber")) {
                builder.groupNumber(extractValue(line));
            }
            if (line.contains("GroupName")) {
                builder.groupName(extractValue(line));
            }
            if (line.contains("LoggedAt")) {
                builder.loggedAt(extractValue(line));
            }
        }
        return builder.build();
    }

    private String extractValue(String line) {
        return line.split(",")[1].trim();
    }
}
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class DocumentRequest {

    private String metadataFileContent;     // TXT
    private String dataFileContent;         // Base64 PDF
    private String dataFileContentType;     // always "application/pdf"
    private String dataFileName;            // PDF file name
    private String metadataFileName;        // TXT file name
}
@Component
public class DestinationUrlBuilder {

    public String buildDestinationUrl(String fileName, MetadataModel metadata) {

        return String.format("filenet://%s?one=%s&two=%s&three=%s",
                fileName,
                metadata.getOne(),
                metadata.getTwo(),
                metadata.getThree()
        );
    }
} 
@Component
public class MetadataParser {

    public MetadataModel parse(String txt) {

        MetadataModel.MetadataModelBuilder builder = MetadataModel.builder();

        String[] lines = txt.split("[;\n]");

        for (String line : lines) {
            if (line.contains("GroupNumber")) {
                builder.one(extract(line));
            }
            if (line.contains("GroupName")) {
                builder.two(extract(line));
            }
            if (line.contains("LoggedAt")) {
                builder.three(extract(line));
            }
        }
        return builder.build();
    }

    private String extract(String line) {
        return line.split(",")[1].trim();
    }
}
@Component
public class MetadataParserUtil {

    public MetadataModel parseTxtToMetadata(String txtContent, String fileName) throws ApplicationException {
        try {
            MetadataModel.MetadataModelBuilder builder = MetadataModel.builder();

            String[] lines = txtContent.split("[;\n]");

            for (String line : lines) {
                if (line.contains("GroupNumber")) {
                    builder.one(extract(line));
                }
                if (line.contains("GroupName")) {
                    builder.two(extract(line));
                }
                if (line.contains("LoggedAt")) {
                    builder.three(extract(line));
                }
            }

            MetadataModel metadata = builder.build();

            // VALIDATION
            if (metadata.getOne() == null || metadata.getTwo() == null || metadata.getThree() == null) {
                throw new ApplicationException(
                        "Metadata TXT missing required fields in file: " + fileName,
                        null,
                        ExceptionType.TECHNICAL
                );
            }

            return metadata;

        } catch (ApplicationException e) {
            throw e;
        } catch (Exception e) {
            throw new ApplicationException(
                    "Failed to parse metadata TXT file: " + fileName,
                    e,
                    ExceptionType.TECHNICAL
            );
        }
    }

    private String extract(String line) {
        return line.split(",")[1].trim();
    }
}
@Component
public class FileConversionUtil {

    public byte[] convertBase64ToBytes(String base64, String fileName) throws ApplicationException {
        try {
            return Base64.getDecoder().decode(base64);
        } catch (Exception e) {
            throw new ApplicationException(
                    "Failed to convert Base64 for file: " + fileName,
                    e,
                    ExceptionType.TECHNICAL
            );
        }
    }
}
@Service
@RequiredArgsConstructor
public class DocumentProcessingService {

    private final FileConversionUtil fileConversionUtil;
    private final MetadataParserUtil metadataParserUtil;
    private final DestinationUrlBuilder destinationUrlBuilder;
    private final S3StorageService s3StorageService;
    private final FileTransferProducer fileTransferProducer;

    public void processDocument(DocumentRequest request) throws ApplicationException {

        // 1. Convert Base64 → PDF (with error handling)
        byte[] pdfBytes = fileConversionUtil.convertBase64ToBytes(
                request.getDataFileContent(),
                request.getDataFileName()
        );

        // 2. Parse TXT → Model (with error handling)
        MetadataModel metadata = metadataParserUtil.parseTxtToMetadata(
                request.getMetadataFileContent(),
                request.getMetadataFileName()
        );

        // 3. Upload PDF
        s3StorageService.uploadObject(
                request.getDataFileName(),
                pdfBytes,
                request.getDataFileContentType(),
                null
        );

        // 4. Upload TXT
        s3StorageService.uploadObject(
                request.getMetadataFileName(),
                request.getMetadataFileContent().getBytes(StandardCharsets.UTF_8),
                "text/plain",
                null
        );

        // 5. Build Destination URL
        String destinationUrl = destinationUrlBuilder.buildDestinationUrl(
                request.getDataFileName(),
                metadata
        );

        // 6. Publish Event
        FileTransferRequest transferRequest = FileTransferRequest.builder()
                .sourceURI("s3://" + request.getDataFileName())
                .destinationURIs(List.of(destinationUrl))
                .isresponseRequired(true)
                .build();

        FileTransferEvent event = FileTransferEvent.builder()
                .fileTransferRequest(transferRequest)
                .build();

        fileTransferProducer.send(event);
    }
}
