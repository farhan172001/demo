public interface MQQueueManagerFactory {
    MQQueueManager create(String managerName) throws MQException;
}



@RequiredArgsConstructor
@Scope("singleton")
public class MQQueuePool extends ObjectPool<MQQueue> {

    private final Environment env;
    private final MQQueueManagerFactory factory;

    // Prefer instance variable unless static is required.
    private static MQQueueManager mqQueueManager;

    private String mqHost;
    private String mqPort;
    private String mqChannel;
    private String mqUsername;
    private String mqPassword;
    private String mqName;
    private String mqManagerName;

    @PostConstruct
    void initializeMQQueuePool() throws ApplicationException {
        AppLogger.info(getClass(), "Initializing MQ Queue Pool...");

        try {
            if (mqQueueManager == null || !mqQueueManager.isConnected()) {

                mqHost         = env.getProperty("mqHostName", "upico.aflac.com");
                mqPort         = env.getProperty("mqPort", "1416");
                mqChannel      = env.getProperty("mqChannelName", "EIB.TO.PC01");
                mqName         = env.getProperty("mqQueueName", "AG.EOS.TO.EIB.IMAGE.DATA");
                mqManagerName  = env.getProperty("mqManagerName", "PC01");
                mqUsername     = env.getProperty("mqUserName");
                mqPassword     = env.getProperty("mqPassword");

                MQEnvironment.hostname = mqHost;
                MQEnvironment.port     = Integer.parseInt(mqPort);
                MQEnvironment.channel  = mqChannel;

                AppLogger.info(
                        getClass(),
                        String.format(
                                "MQ Config loaded Manager: %s, Host: %s:%s, Channel: %s, Queue: %s, User: %s",
                                mqManagerName,
                                mqHost,
                                mqPort,
                                mqChannel,
                                mqName,
                                mqUsername != null ? mqUsername : "N/A"
                        )
                );
            }

            mqQueueManager = factory.create(mqManagerName);

        } catch (MQException e) {
            AppLogger.error(getClass(),
                    "MQException while opening queue " + mqName, e);
            throw new ApplicationException(
                    "Failed to open MQ Queue: " + mqName,
                    e,
                    ExceptionType.TECHNICAL
            );

        } catch (Exception e) {
            AppLogger.error(getClass(),
                    "Unexpected error during MQ initialization", e);
            throw new ApplicationException(
                    "Unexpected error during MQ initialization",
                    e,
                    ExceptionType.TECHNICAL
            );
        }
    }

    @Override
    public MQQueue create() throws ApplicationException {
        AppLogger.info(getClass(), "MQQueuePool.create - ENTER");

        try {
            if (mqQueueManager == null || !mqQueueManager.isConnected()) {
                initializeMQQueuePool();
            }

            int openOptions =
                    MQC.MQOO_INQUIRE |
                            MQC.MQOO_FAIL_IF_QUIESCING |
                            MQC.MQOO_INPUT_AS_Q_DEF;

            MQQueue queue = mqQueueManager.accessQueue(mqName, openOptions);

            AppLogger.info(
                    getClass(),
                    "MQQueuePool.create MQ Queue created successfully: " + mqName
            );

            return queue;

        } catch (Exception ex) {
            AppLogger.error(
                    getClass(),
                    "MQQueuePool.create Error creating MQ Queue: " + mqName,
                    ex
            );
            throw new ApplicationException(
                    "Unable to create MQ queue: " + mqName,
                    ex,
                    ExceptionType.TECHNICAL
            );

        } finally {
            AppLogger.info(getClass(), "MQQueuePool.create - EXIT");
        }
    }

    @Override
    public void expire(MQQueue queue) throws ApplicationException {
        AppLogger.info(getClass(), "MQQueuePool.expire - ENTER");

        try {
            if (queue == null) {
                AppLogger.warn(getClass(),
                        "MQQueuePool.expire Queue is null, nothing to close");
                return;
            }

            if (queue.isOpen()) {
                queue.close();
            }

        } catch (Exception ex) {
            AppLogger.error(getClass(),
                    "MQQueuePool.expire Error closing MQ Queue", ex);
            throw new ApplicationException(
                    "Failed to close MQ Queue",
                    ex,
                    ExceptionType.TECHNICAL
            );

        } finally {
            AppLogger.info(getClass(), "MQQueuePool.expire - EXIT");
        }
    }

    @Override
    public boolean validate(MQQueue queue) {
        AppLogger.info(getClass(), "MQQueuePool.validate - ENTER");

        try {
            if (queue == null) {
                AppLogger.warn(getClass(),
                        "MQQueuePool.validate Queue is null");
                return false;
            }

            boolean isOpen = queue.isOpen();

            AppLogger.info(
                    getClass(),
                    "MQQueuePool.validate Queue validation result: " + isOpen
            );

            return isOpen;

        } catch (Exception ex) {
            AppLogger.error(getClass(),
                    "MQQueuePool.validate Exception during validation", ex);
            return false;
        }
    }
}







import com.ibm.mq.MQEnvironment;
import com.ibm.mq.MQException;
import com.ibm.mq.MQQueue;
import com.ibm.mq.MQQueueManager;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.core.env.Environment;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class MQQueuePoolTest {

    private Environment env;
    private MQQueueManagerFactory factory;
    private MQQueueManager manager;
    private MQQueue queue;
    private MQQueuePool pool;

    @BeforeEach
    void setup() throws Exception {
        env = mock(Environment.class);
        factory = mock(MQQueueManagerFactory.class);
        manager = mock(MQQueueManager.class);
        queue = mock(MQQueue.class);

        when(env.getProperty("mqHostName", "upico.aflac.com")).thenReturn("host1");
        when(env.getProperty("mqPort", "1416")).thenReturn("1417");
        when(env.getProperty("mqChannelName", "EIB.TO.PC01")).thenReturn("CH.A");
        when(env.getProperty("mqQueueName", "AG.EOS.TO.EIB.IMAGE.DATA")).thenReturn("Q1");
        when(env.getProperty("mqManagerName", "PC01")).thenReturn("QM1");
        when(env.getProperty("mqUserName")).thenReturn("user1");
        when(env.getProperty("mqPassword")).thenReturn("pass1");

        when(factory.create("QM1")).thenReturn(manager);

        pool = new MQQueuePool(env, factory);

        // Clear static manager before each test
        MQQueuePool.mqQueueManager = null;
    }

    @Test
    void initialize_setsEnvironment_andCreatesManager() throws Exception {
        when(manager.isConnected()).thenReturn(true);

        pool.initializeMQQueuePool();

        assertEquals("host1", MQEnvironment.hostname);
        assertEquals(1417, MQEnvironment.port);
        assertEquals("CH.A", MQEnvironment.channel);

        assertNotNull(MQQueuePool.mqQueueManager);
        verify(factory, times(1)).create("QM1");
    }

    @Test
    void initialize_wrapsMQException() throws Exception {
        when(factory.create(anyString()))
                .thenThrow(new MQException(2, 2009, "fail"));

        ApplicationException ex = assertThrows(
                ApplicationException.class,
                () -> pool.initializeMQQueuePool()
        );

        assertTrue(
                ex.getMessage().contains("Failed to open MQ Queue")
                        || ex.getMessage().contains("Unexpected")
        );
    }

    @Test
    void create_returnsQueue_whenConnected() throws Exception {
        when(manager.isConnected()).thenReturn(true);
        when(manager.accessQueue(eq("Q1"), anyInt())).thenReturn(queue);

        MQQueue q = pool.create();
        assertSame(queue, q);

        verify(manager, times(1)).accessQueue(eq("Q1"), anyInt());
    }

    @Test
    void create_reinitializes_whenNotConnected() throws Exception {
        when(manager.isConnected())
                .thenReturn(false)
                .thenReturn(true);

        when(manager.accessQueue(eq("Q1"), anyInt())).thenReturn(queue);

        MQQueue q = pool.create();
        assertSame(queue, q);

        verify(factory, atLeastOnce()).create("QM1");
        verify(manager, times(1)).accessQueue(eq("Q1"), anyInt());
    }

    @Test
    void create_wrapsErrors() throws Exception {
        when(manager.isConnected()).thenReturn(true);
        when(manager.accessQueue(anyString(), anyInt()))
                .thenThrow(new RuntimeException("boom"));

        assertThrows(ApplicationException.class, () -> pool.create());
    }

    @Test
    void expire_closes_whenOpen() throws Exception {
        when(queue.isOpen()).thenReturn(true);

        pool.expire(queue);

        verify(queue).close();
    }

    @Test
    void expire_noopOnNullOrClosed() throws Exception {
        assertDoesNotThrow(() -> pool.expire(null));

        when(queue.isOpen()).thenReturn(false);

        pool.expire(queue);

        verify(queue, never()).close();
    }

    @Test
    void expire_wrapsCloseErrors() throws Exception {
        when(queue.isOpen()).thenReturn(true);

        doThrow(new MQException(2, 2009, "close-fail"))
                .when(queue).close();

        assertThrows(ApplicationException.class, () -> pool.expire(queue));
    }

    @Test
    void validate_behavesAsExpected() {
        assertFalse(pool.validate(null));

        when(queue.isOpen()).thenReturn(true);
        assertTrue(pool.validate(queue));

        when(queue.isOpen()).thenReturn(false);
        assertFalse(pool.validate(queue));
    }

    @Test
    void objectPool_checkout_checkIn_reuses() throws Exception {
        when(manager.isConnected()).thenReturn(true);
        when(manager.accessQueue(eq("Q1"), anyInt())).thenReturn(queue);

        pool.expirationTime = 10_000L;

        MQQueue q1 = pool.checkout();
        assertSame(queue, q1);

        pool.checkIn(q1);

        MQQueue q2 = pool.checkout();
        assertSame(q1, q2);
    }
}








class ObjectPoolTest {

    private TestObjectPool pool;
    private String testObject;

    // Concrete implementation for testing
    private static class TestObjectPool extends ObjectPool<String> {
        private boolean shouldValidate = true;
        private boolean shouldThrowOnCreate = false;
        private boolean shouldThrowOnExpire = false;
        private int createCallCount = 0;
        private int validateCallCount = 0;
        private int expireCallCount = 0;

        @Override
        protected String create() throws ApplicationException {
            createCallCount++;
            if (shouldThrowOnCreate) {
                throw new ApplicationException("Create failed");
            }
            return "Object-" + createCallCount;
        }

        @Override
        protected boolean validate(String obj) {
            validateCallCount++;
            return shouldValidate;
        }

        @Override
        protected void expire(String obj) throws ApplicationException {
            expireCallCount++;
            if (shouldThrowOnExpire) {
                throw new ApplicationException("Expire failed");
            }
        }

        public void setShouldValidate(boolean shouldValidate) {
            this.shouldValidate = shouldValidate;
        }

        public void setShouldThrowOnCreate(boolean shouldThrow) {
            this.shouldThrowOnCreate = shouldThrow;
        }

        public void setShouldThrowOnExpire(boolean shouldThrow) {
            this.shouldThrowOnExpire = shouldThrow;
        }

        public int getCreateCallCount() {
            return createCallCount;
        }

        public int getValidateCallCount() {
            return validateCallCount;
        }

        public int getExpireCallCount() {
            return expireCallCount;
        }
    }

    @BeforeEach
    void setUp() {
        pool = new TestObjectPool();
        testObject = "TestObject";
    }

    @Test
    @DisplayName("Constructor initializes with default expiration time")
    void constructor_initializesDefaultExpirationTime() {
        assertEquals(60000L, pool.expirationTime);
    }

    @Test
    @DisplayName("Constructor initializes empty locked and unlocked hashtables")
    void constructor_initializesEmptyHashtables() throws Exception {
        Hashtable<String, Long> locked = getLockedHashtable();
        Hashtable<String, Long> unlocked = getUnlockedHashtable();

        assertNotNull(locked);
        assertNotNull(unlocked);
        assertEquals(0, locked.size());
        assertEquals(0, unlocked.size());
    }

    @Test
    @DisplayName("Checkout creates new object when pool is empty")
    void checkout_createsNewObject_whenPoolIsEmpty() throws Exception {
        String obj = pool.checkout();

        assertNotNull(obj);
        assertEquals("Object-1", obj);
        assertEquals(1, pool.getCreateCallCount());

        Hashtable<String, Long> locked = getLockedHashtable();
        assertEquals(1, locked.size());
        assertTrue(locked.containsKey(obj));
    }

    @Test
    @DisplayName("Checkout reuses valid unlocked object")
    void checkout_reusesValidObject_fromUnlockedPool() throws Exception {
        // First checkout
        String obj1 = pool.checkout();
        pool.checkIn(obj1);

        // Second checkout should reuse
        String obj2 = pool.checkout();

        assertSame(obj1, obj2);
        assertEquals(1, pool.getCreateCallCount());
        assertEquals(1, pool.getValidateCallCount());

        Hashtable<String, Long> locked = getLockedHashtable();
        Hashtable<String, Long> unlocked = getUnlockedHashtable();
        assertEquals(1, locked.size());
        assertEquals(0, unlocked.size());
    }

    @Test
    @DisplayName("Checkout expires and recreates invalid object")
    void checkout_expiresInvalidObject_andCreatesNew() throws Exception {
        String obj1 = pool.checkout();
        pool.checkIn(obj1);

        // Make validation fail
        pool.setShouldValidate(false);

        String obj2 = pool.checkout();

        assertNotSame(obj1, obj2);
        assertEquals(2, pool.getCreateCallCount());
        assertEquals(1, pool.getValidateCallCount());
        assertEquals(1, pool.getExpireCallCount());
    }

    @Test
    @DisplayName("Checkout expires objects that exceed expiration time")
    void checkout_expiresOldObjects() throws Exception {
        // Set very short expiration time
        pool.expirationTime = 10L;

        String obj1 = pool.checkout();
        pool.checkIn(obj1);

        // Wait for expiration
        Thread.sleep(50);

        String obj2 = pool.checkout();

        assertNotSame(obj1, obj2);
        assertEquals(2, pool.getCreateCallCount());
        assertEquals(1, pool.getExpireCallCount());
        assertEquals(0, pool.getValidateCallCount()); // Expired before validation
    }

    @Test
    @DisplayName("Checkout handles multiple expired objects")
    void checkout_handlesMultipleExpiredObjects() throws Exception {
        pool.expirationTime = 10L;

        // Create and check in multiple objects
        String obj1 = pool.checkout();
        pool.checkIn(obj1);
        String obj2 = pool.checkout();
        pool.checkIn(obj2);
        String obj3 = pool.checkout();
        pool.checkIn(obj3);

        // Wait for expiration
        Thread.sleep(50);

        // Checkout should expire all and create new
        String newObj = pool.checkout();

        assertNotNull(newObj);
        assertEquals(4, pool.getCreateCallCount());
        assertEquals(3, pool.getExpireCallCount());
    }

    @Test
    @DisplayName("Checkout throws ApplicationException when create fails")
    void checkout_throwsException_whenCreateFails() {
        pool.setShouldThrowOnCreate(true);

        assertThrows(ApplicationException.class, () -> pool.checkout());
    }

    @Test
    @DisplayName("Checkout propagates ApplicationException from expire")
    void checkout_propagatesException_whenExpireFails() throws Exception {
        String obj = pool.checkout();
        pool.checkIn(obj);

        pool.setShouldValidate(false);
        pool.setShouldThrowOnExpire(true);

        assertThrows(ApplicationException.class, () -> pool.checkout());
    }

    @Test
    @DisplayName("CheckIn moves object from locked to unlocked")
    void checkIn_movesObjectToUnlocked() throws Exception {
        String obj = pool.checkout();

        Hashtable<String, Long> locked = getLockedHashtable();
        Hashtable<String, Long> unlocked = getUnlockedHashtable();

        assertEquals(1, locked.size());
        assertEquals(0, unlocked.size());

        pool.checkIn(obj);

        assertEquals(0, locked.size());
        assertEquals(1, unlocked.size());
        assertTrue(unlocked.containsKey(obj));
    }

    @Test
    @DisplayName("CheckIn records current timestamp")
    void checkIn_recordsCurrentTimestamp() throws Exception {
        String obj = pool.checkout();

        long beforeCheckIn = System.currentTimeMillis();
        pool.checkIn(obj);
        long afterCheckIn = System.currentTimeMillis();

        Hashtable<String, Long> unlocked = getUnlockedHashtable();
        Long timestamp = unlocked.get(obj);

        assertNotNull(timestamp);
        assertTrue(timestamp >= beforeCheckIn && timestamp <= afterCheckIn);
    }

    @Test
    @DisplayName("Multiple checkout and checkin cycles work correctly")
    void multipleCheckoutCheckinCycles() throws Exception {
        // Cycle 1
        String obj1 = pool.checkout();
        pool.checkIn(obj1);

        // Cycle 2 - should reuse
        String obj2 = pool.checkout();
        assertSame(obj1, obj2);
        pool.checkIn(obj2);

        // Cycle 3 - should reuse
        String obj3 = pool.checkout();
        assertSame(obj1, obj3);

        assertEquals(1, pool.getCreateCallCount());
        assertEquals(2, pool.getValidateCallCount());
    }

    @Test
    @DisplayName("Pool handles concurrent-like sequential operations")
    void pool_handlesSequentialOperations() throws Exception {
        String obj1 = pool.checkout();
        String obj2 = pool.checkout();
        String obj3 = pool.checkout();

        assertNotSame(obj1, obj2);
        assertNotSame(obj2, obj3);
        assertNotSame(obj1, obj3);

        pool.checkIn(obj1);
        pool.checkIn(obj2);
        pool.checkIn(obj3);

        Hashtable<String, Long> unlocked = getUnlockedHashtable();
        assertEquals(3, unlocked.size());

        // Checkout should reuse one of them
        String reused = pool.checkout();
        assertTrue(reused.equals(obj1) || reused.equals(obj2) || reused.equals(obj3));
    }

    @Test
    @DisplayName("Expiration time can be customized")
    void expirationTime_canBeCustomized() {
        pool.expirationTime = 120000L;
        assertEquals(120000L, pool.expirationTime);
    }

    @Test
    @DisplayName("Checkout with mix of expired and valid objects")
    void checkout_withMixOfExpiredAndValidObjects() throws Exception {
        pool.expirationTime = 100L;

        // Create first object
        String obj1 = pool.checkout();
        pool.checkIn(obj1);

        // Wait a bit
        Thread.sleep(50);

        // Create second object (should not be expired yet)
        String obj2 = pool.checkout();
        pool.checkIn(obj2);

        // Wait for first to expire but not second
        Thread.sleep(60);

        // Next checkout should expire obj1 but use obj2
        String reused = pool.checkout();

        assertSame(obj2, reused);
        assertEquals(2, pool.getCreateCallCount());
        assertEquals(1, pool.getExpireCallCount());
        assertEquals(1, pool.getValidateCallCount());
    }

    @Test
    @DisplayName("CheckIn on non-locked object still works")
    void checkIn_onNonLockedObject() throws Exception {
        String arbitraryObj = "arbitrary";

        // Should not throw exception
        assertDoesNotThrow(() -> pool.checkIn(arbitraryObj));

        Hashtable<String, Long> unlocked = getUnlockedHashtable();
        assertTrue(unlocked.containsKey(arbitraryObj));
    }

    // Helper methods to access private fields using reflection
    @SuppressWarnings("unchecked")
    private Hashtable<String, Long> getLockedHashtable() throws Exception {
        Field lockedField = ObjectPool.class.getDeclaredField("locked");
        lockedField.setAccessible(true);
        return (Hashtable<String, Long>) lockedField.get(pool);
    }

    @SuppressWarnings("unchecked")
    private Hashtable<String, Long> getUnlockedHashtable() throws Exception {
        Field unlockedField = ObjectPool.class.getDeclaredField("unlocked");
        unlockedField.setAccessible(true);
        return (Hashtable<String, Long>) unlockedField.get(pool);
    }
}





@Test
@DisplayName("Checkout handles multiple expired objects before finding valid one")
void checkout_handlesMultipleExpiredObjects() throws Exception {
    pool.expirationTime = 1000L;

    // Create objects
    String obj1 = pool.checkout();
    pool.checkIn(obj1);
    String obj2 = pool.checkout();
    pool.checkIn(obj2);
    String obj3 = pool.checkout(); // Keep this one locked/fresh
    
    // Manually expire obj1 and obj2 using reflection
    Hashtable<String, Long> unlocked = getUnlockedHashtable();
    long expiredTime = System.currentTimeMillis() - 2000L;
    unlocked.put(obj1, expiredTime);
    unlocked.put(obj2, expiredTime);

    // Check in obj3 as fresh
    pool.checkIn(obj3);

    int expireCountBefore = pool.getExpireCallCount();
    
    // Checkout should expire obj1, obj2 and potentially use obj3 or create new
    String result = pool.checkout();

    assertNotNull(result);
    // At least 2 objects (obj1, obj2) should be expired during enumeration
    assertTrue(pool.getExpireCallCount() >= expireCountBefore + 2,
        "Should have expired at least 2 objects");
}
