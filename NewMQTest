class MQQueuePoolTest {

    private Environment env;
    private MQQueuePool pool;

    @BeforeEach
    void setup() throws Exception {

        env = mock(Environment.class);

        when(env.getProperty("mqHostName", "upico.aflac.com")).thenReturn("host1");
        when(env.getProperty("mqPort", "1416")).thenReturn("1417");
        when(env.getProperty("mqChannelName", "EIB.TO.PC01")).thenReturn("CH.A");
        when(env.getProperty("mqQueueName", "AG.EOS.TO.EIB.IMAGE.DATA")).thenReturn("Q1");
        when(env.getProperty("mqManagerName", "PC01")).thenReturn("QM1");
        when(env.getProperty("mqUserName")).thenReturn("user1");
        when(env.getProperty("mqPassword")).thenReturn("pass1");

        pool = new MQQueuePool(env);

        // Reset static manager
        Field f = MQQueuePool.class.getDeclaredField("mqQueueManager");
        f.setAccessible(true);
        f.set(null, null);
    }

    @AfterEach
    void tearDown() throws Exception {
        Field f = MQQueuePool.class.getDeclaredField("mqQueueManager");
        f.setAccessible(true);
        f.set(null, null);
    }

    // -------------------------------------------------------------------------

    @Test
    void create_shouldInitializeEnvironment_andReturnQueue() throws Exception {

        MQQueue queueMock = mock(MQQueue.class);

        try (MockedConstruction<MQQueueManager> cons =
                Mockito.mockConstruction(MQQueueManager.class, (mock, ctx) -> {

                    // First call: manager is created → assume not connected
                    // Second call: after initialize → treat as connected
                    when(mock.isConnected()).thenReturn(false, true);

                    when(mock.accessQueue(eq("Q1"), anyInt()))
                            .thenReturn(queueMock);
                })) {

            MQQueue q = pool.create();

            assertNotNull(q);
            assertSame(queueMock, q);

            assertEquals("host1", MQEnvironment.hostname);
            assertEquals(1417, MQEnvironment.port);
            assertEquals("CH.A", MQEnvironment.channel);

            MQQueueManager mgr = cons.constructed().get(0);

            verify(mgr, times(1))
                    .accessQueue(eq("Q1"), anyInt());
        }
    }

    // -------------------------------------------------------------------------

    @Test
    void create_shouldThrowApplicationException_whenMQException() throws Exception {

        try (MockedConstruction<MQQueueManager> cons =
                Mockito.mockConstruction(MQQueueManager.class, (mock, ctx) -> {
                    when(mock.isConnected()).thenReturn(false, true);
                    when(mock.accessQueue(anyString(), anyInt()))
                            .thenThrow(new MQException(2, 2009, "ConnFail"));
                })) {

            ApplicationException ex =
                    assertThrows(ApplicationException.class, () -> pool.create());

            assertTrue(ex.getMessage().contains("Unable to create MQ queue"));
        }
    }

    // -------------------------------------------------------------------------

    @Test
    void expire_shouldClose_whenOpen() throws Exception {

        MQQueue q = mock(MQQueue.class);
        when(q.isOpen()).thenReturn(true);

        pool.expire(q);

        verify(q).close();
    }

    @Test
    void expire_shouldDoNothing_whenNull() {
        assertDoesNotThrow(() -> pool.expire(null));
    }

    @Test
    void expire_shouldNotClose_whenNotOpen() throws Exception {

        MQQueue q = mock(MQQueue.class);
        when(q.isOpen()).thenReturn(false);

        pool.expire(q);

        verify(q, never()).close();
    }

    // -------------------------------------------------------------------------

    @Test
    void validate_shouldReturnFalse_whenNull() {
        assertFalse(pool.validate(null));
    }

    @Test
    void validate_shouldReturnTrue_whenOpen() throws Exception {

        MQQueue q = mock(MQQueue.class);
        when(q.isOpen()).thenReturn(true);

        assertTrue(pool.validate(q));
    }

    @Test
    void validate_shouldReturnFalse_whenClosed_orException() throws Exception {

        MQQueue closed = mock(MQQueue.class);
        when(closed.isOpen()).thenReturn(false);

        MQQueue throwsEx = mock(MQQueue.class);
        when(throwsEx.isOpen()).thenThrow(new RuntimeException());

        assertFalse(pool.validate(closed));
        assertFalse(pool.validate(throwsEx));
    }
}





package com.aflac.eib.extream.content.configuration.mq;

import com.aflac.eib.lib.exception.custom.base.ApplicationException;
import com.aflac.eib.lib.exception.custom.base.ExceptionType;
import com.ibm.mq.MQException;
import com.ibm.mq.MQQueue;
import com.ibm.mq.MQQueueManager;
import com.ibm.mq.constants.MQC;
import com.ibm.mq.MQEnvironment;
import org.junit.jupiter.api.*;
import org.mockito.MockedConstruction;
import org.mockito.Mockito;
import org.springframework.core.env.Environment;

import java.lang.reflect.Field;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

class MQQueuePoolTest {

    private Environment env;
    private MQQueuePool pool;

    // Utility to reset static mqQueueManager
    private void resetStaticManager() throws Exception {
        Field field = MQQueuePool.class.getDeclaredField("mqQueueManager");
        field.setAccessible(true);
        field.set(null, null);
    }

    @BeforeEach
    void setup() throws Exception {
        env = mock(Environment.class);

        when(env.getProperty("mqHostName", "upico.aflac.com")).thenReturn("my.host");
        when(env.getProperty("mqPort", "1416")).thenReturn("1416");
        when(env.getProperty("mqChannelName", "EIB.TO.PC01")).thenReturn("MY.CHANNEL");
        when(env.getProperty("mqQueueName", "AG.EOS.TO.EIB.IMAGE.DATA")).thenReturn("MY.QUEUE");
        when(env.getProperty("mqManagerName", "PC01")).thenReturn("MYQMGR");
        when(env.getProperty("mqUserName")).thenReturn("user1");
        when(env.getProperty("mqPassword")).thenReturn("pwd1");

        pool = new MQQueuePool(env);
        resetStaticManager();
    }

    @AfterEach
    void tearDown() throws Exception {
        resetStaticManager();
    }

    // ----------------------------------------------------------------------

    @Test
    void initialize_success_setsEnvironmentAndCreatesManager() throws Exception {

        try (MockedConstruction<MQQueueManager> construction =
                     Mockito.mockConstruction(MQQueueManager.class,
                             (mock, context) -> when(mock.isConnected()).thenReturn(true))
        ) {

            pool.initializeMQQueuePool();

            assertEquals("my.host", MQEnvironment.hostname);
            assertEquals(1416, MQEnvironment.port);
            assertEquals("MY.CHANNEL", MQEnvironment.channel);

            assertEquals(1, construction.constructed().size());
        }
    }

    @Test
    void initialize_whenMQException_wrapsInApplicationException() throws Exception {

        try (MockedConstruction<MQQueueManager> construction =
                     Mockito.mockConstruction(MQQueueManager.class,
                             (mock, context) -> {
                                 throw new MQException(2, 2035, "AuthError");
                             })) {

            ApplicationException ex =
                    assertThrows(ApplicationException.class, () -> pool.initializeMQQueuePool());

            assertTrue(ex.getMessage().contains("Failed to open MQ Queue"));
            assertEquals(ExceptionType.TECHNICAL, ex.getType());
        }
    }

    @Test
    void initialize_whenUnexpectedException_wrapsInApplicationException() throws Exception {

        when(env.getProperty("mqPort", "1416")).thenReturn("badPort"); // force NumberFormatException

        ApplicationException ex =
                assertThrows(ApplicationException.class, () -> pool.initializeMQQueuePool());

        assertTrue(ex.getMessage().contains("Unexpected error"));
        assertEquals(ExceptionType.TECHNICAL, ex.getType());
    }

    // ----------------------------------------------------------------------

    @Test
    void create_whenManagerNull_initializesAndAccessesQueue() throws Exception {

        MQQueue queueMock = mock(MQQueue.class);

        try (MockedConstruction<MQQueueManager> construction =
                     Mockito.mockConstruction(MQQueueManager.class,
                             (mock, context) -> {
                                 when(mock.isConnected()).thenReturn(false);
                                 when(mock.accessQueue(eq("MY.QUEUE"), anyInt()))
                                         .thenReturn(queueMock);
                             })) {

            MQQueue result = pool.create();

            assertNotNull(result);

            verify(construction.constructed().get(0), times(1))
                    .accessQueue(eq("MY.QUEUE"),
                            eq(MQC.MQOO_INQUIRE
                                    | MQC.MQOO_FAIL_IF_QUIESCING
                                    | MQC.MQOO_INPUT_SHARED));
        }
    }

    @Test
    void create_whenManagerDisconnected_reinitializesAndAccessesQueue() throws Exception {

        MQQueue queueMock = mock(MQQueue.class);

        try (MockedConstruction<MQQueueManager> construction =
                     Mockito.mockConstruction(MQQueueManager.class,
                             (mock, context) -> {
                                 if (construction.constructed().isEmpty()) {
                                     when(mock.isConnected()).thenReturn(false);
                                 } else {
                                     when(mock.isConnected()).thenReturn(true);
                                     when(mock.accessQueue(eq("MY.QUEUE"), anyInt()))
                                             .thenReturn(queueMock);
                                 }
                             })) {

            MQQueue result = pool.create();
            assertNotNull(result);

            assertTrue(construction.constructed().size() >= 1);
        }
    }

    @Test
    void create_whenAccessQueueThrows_wrapsInApplicationException() throws Exception {

        try (MockedConstruction<MQQueueManager> ignored =
                     Mockito.mockConstruction(MQQueueManager.class,
                             (mock, context) -> {
                                 when(mock.isConnected()).thenReturn(true);
                                 when(mock.accessQueue(anyString(), anyInt()))
                                         .thenThrow(new RuntimeException("boom"));
                             })) {

            ApplicationException ex =
                    assertThrows(ApplicationException.class, () -> pool.create());

            assertTrue(ex.getMessage().contains("Unable to create MQ queue"));
            assertEquals(ExceptionType.TECHNICAL, ex.getType());
        }
    }

    // ----------------------------------------------------------------------

    @Test
    void validate_returnsFalse_whenQueueNull() {
        assertFalse(pool.validate(null));
    }

    @Test
    void validate_returnsTrue_whenQueueIsOpen() {
        MQQueue queue = mock(MQQueue.class);
        when(queue.isOpen()).thenReturn(true);

        assertTrue(pool.validate(queue));
        verify(queue).isOpen();
    }

    @Test
    void validate_returnsFalse_whenQueueIsClosed() {
        MQQueue queue = mock(MQQueue.class);
        when(queue.isOpen()).thenReturn(false);

        assertFalse(pool.validate(queue));
    }

    @Test
    void validate_returnsFalse_whenExceptionThrown() {
        MQQueue queue = mock(MQQueue.class);
        when(queue.isOpen()).thenThrow(new RuntimeException("error"));

        assertFalse(pool.validate(queue));
    }

    // ----------------------------------------------------------------------

    @Test
    void expire_noop_whenNull() {
        assertDoesNotThrow(() -> pool.expire(null));
    }

    @Test
    void expire_closes_whenOpen() throws Exception {
        MQQueue queue = mock(MQQueue.class);
        when(queue.isOpen()).thenReturn(true);

        assertDoesNotThrow(() -> pool.expire(queue));
        verify(queue).close();
    }

    @Test
    void expire_doesNotClose_whenNotOpen() throws Exception {
        MQQueue queue = mock(MQQueue.class);
        when(queue.isOpen()).thenReturn(false);

        assertDoesNotThrow(() -> pool.expire(queue));
        verify(queue, never()).close();
    }

    @Test
    void expire_wrapsExceptionInApplicationException() throws Exception {

        MQQueue queue = mock(MQQueue.class);
        when(queue.isOpen()).thenReturn(true);
        doThrow(new RuntimeException("close failed")).when(queue).close();

        ApplicationException ex =
                assertThrows(ApplicationException.class, () -> pool.expire(queue));

        assertTrue(ex.getMessage().contains("Failed to close MQ Queue"));
        assertEquals(ExceptionType.TECHNICAL, ex.getType());
    }
}


org.opentest4y.AssertionFailedError: Unexpected exception type thrown, Expected class. com.aflac.eib.lib.exception.ouston.base.ApplicationException

Actual class org.mockito.exceptions.base.Rockitočxception

<Click to see difference>

> <4 internal Lines

ms

>

at com.aflac.cib.extream.content.configuration.mg.ngqueusPoolTest.initi

14 ms

33 ms

9ms

at java.base/java.util.ArrayList.forEach(ArrayList: en:15313

at java.base/java.util.ArrayList.forEach(ArrayList.love 15117

30 ms

2122 ms

37 m

te 5ms

Caused by: org.nockito.exceptions.base.MockitoException: Could not Initialized

at com.ibm.ng.QQueunManager.<init>(NQQueueñanager.java)

at com.sflac.eib.extream.content.configuration.mq.80QueuePool.initializ at com.aflac.nib.extream.content.configuration.ng.RQQueuePoolTestame

& more

Caused by: com.ibm.mq.MOException Create breakpot: RQJ2003: Completion Cune 2

at com.aflec.eib.extream.content.configuration.mq.QueuePuolastammti

10 more
org.opentest4j. AssertionFailedError:

Expected:MY.CHANNEL

Actual

:null

<Click to see difference>
