package com.aflac.eib.mq;

import com.aflac.eib.lib.kafka.logging.AppLogger;
import com.ibm.msg.client.wmq.WMQConstants;
import com.ibm.mq.jms.MQQueueConnectionFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;
import org.springframework.core.env.Environment;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.jms.*;
import java.util.concurrent.ConcurrentLinkedQueue;

@Configuration
@Scope("singleton")
public class MQQueuePool extends ObjectPool<QueueSession> {

    @Autowired
    private Environment env;

    private MQQueueConnectionFactory factory;
    private QueueConnection queueConnection;

    private String mqHostName;
    private int mqPort;
    private String mqChannelName;
    private String mqQueueName;
    private String mqManagerName;
    private String mqUserName;
    private String mqPassword;

    public MQQueuePool() {
        super();
    }

    @PostConstruct
    private void initializeMQQueuePool() {
        AppLogger.info(this.getClass(), "Initializing MQ Queue Pool...");

        try {
            loadMQConfiguration();
            initializeFactory();
            initializeConnection();
            AppLogger.info(this.getClass(), "MQ Queue Pool initialized successfully");
        } catch (Exception ex) {
            AppLogger.error(this.getClass(), "Failed to initialize MQ Queue Pool: " + ex.getMessage(), ex);
            throw new RuntimeException("MQ Queue Pool initialization failed", ex);
        }
    }

    private void loadMQConfiguration() {
        this.mqManagerName = env.getProperty("mqManagerName", "PCO1");
        this.mqHostName = env.getProperty("mqHostName", "upico.aflac.com");
        this.mqPort = Integer.parseInt(env.getProperty("mqPort", "1416"));
        this.mqChannelName = env.getProperty("mqChannelName", "EIB.TO.PCO1");
        this.mqQueueName = env.getProperty("mqQueueName", "AG.EOS.TO.EIB.IMAGE.DATA");
        this.mqUserName = env.getProperty("mqUserName");
        this.mqPassword = env.getProperty("mqPassword");

        AppLogger.info(this.getClass(), String.format(
                "MQ Config loaded - Manager: %s, Host: %s:%d, Channel: %s, Queue: %s, User: %s",
                mqManagerName, mqHostName, mqPort, mqChannelName, mqQueueName,
                mqUserName != null ? mqUserName : "N/A"
        ));
    }

    private void initializeFactory() throws JMSException {
        factory = new MQQueueConnectionFactory();
        factory.setHostName(mqHostName);
        factory.setPort(mqPort);
        factory.setChannel(mqChannelName);
        factory.setQueueManager(mqManagerName);
        factory.setTransportType(WMQConstants.WMQ_CM_CLIENT);

        if (mqUserName != null && !mqUserName.isEmpty()) {
            factory.setStringProperty(WMQConstants.USERID, mqUserName);
            factory.setStringProperty(WMQConstants.PASSWORD, mqPassword);
        }

        AppLogger.info(this.getClass(), "MQQueueConnectionFactory initialized successfully");
    }

    private void initializeConnection() throws JMSException {
        queueConnection = factory.createQueueConnection();
        queueConnection.start();
        AppLogger.info(this.getClass(), "QueueConnection started successfully");
    }

    @Override
    protected QueueSession create() {
        try {
            QueueSession session = queueConnection.createQueueSession(false, Session.AUTO_ACKNOWLEDGE);
            AppLogger.info(this.getClass(), "QueueSession created successfully");
            return session;
        } catch (JMSException ex) {
            AppLogger.error(this.getClass(), "Failed to create QueueSession: " + ex.getMessage(), ex);
            throw new RuntimeException("Failed to create QueueSession", ex);
        }
    }

    @Override
    protected void expire(QueueSession session) {
        if (session != null) {
            try {
                session.close();
                AppLogger.info(this.getClass(), "QueueSession expired and closed");
            } catch (JMSException ex) {
                AppLogger.error(this.getClass(), "Error closing QueueSession: " + ex.getMessage(), ex);
            }
        }
    }

    @Override
    protected boolean validate(QueueSession session) {
        // Always true for JMS QueueSession; optional advanced validation can be added
        return session != null;
    }

    @PreDestroy
    public void cleanup() {
        shutdown(); // from ObjectPool, closes all sessions
        if (queueConnection != null) {
            try {
                queueConnection.close();
                AppLogger.info(this.getClass(), "QueueConnection closed successfully");
            } catch (JMSException ex) {
                AppLogger.error(this.getClass(), "Error during QueueConnection cleanup: " + ex.getMessage(), ex);
            }
        }
    }

    public boolean isConnected() {
        return queueConnection != null;
    }

    /** Temporary test method to send a message */
    public void testQueue() {
        QueueSession session = null;
        try {
            session = borrowObject();
            Queue queue = session.createQueue(mqQueueName);
            MessageProducer producer = session.createProducer(queue);

            TextMessage message = session.createTextMessage("Test message from MQQueuePool");
            producer.send(message);

            AppLogger.info(this.getClass(), "Test message sent successfully: " + message.getText());

            producer.close();
        } catch (Exception ex) {
            AppLogger.error(this.getClass(), "Error in testQueue: " + ex.getMessage(), ex);
        } finally {
            if (session != null) returnObject(session);
        }
    }
}.   import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public abstract class ObjectPool<T> {

    private ConcurrentLinkedQueue<T> pool;
    private ScheduledExecutorService executorService;
    protected long expirationTime = 60000; // optional per object expiration

    public ObjectPool() {
        this(5, 30); // default: initial size 5, validation interval 30 sec
    }

    public ObjectPool(int initialSize, int validationIntervalSeconds) {
        pool = new ConcurrentLinkedQueue<>();
        for (int i = 0; i < initialSize; i++) {
            pool.add(create());
        }

        executorService = Executors.newSingleThreadScheduledExecutor();
        executorService.scheduleWithFixedDelay(this::validatePool,
                validationIntervalSeconds, validationIntervalSeconds, TimeUnit.SECONDS);
    }

    public T borrowObject() {
        T object = pool.poll();
        if (object == null) {
            object = create();
        } else if (!validate(object)) {
            expire(object);
            object = create();
        }
        return object;
    }

    public void returnObject(T object) {
        if (object == null) return;

        if (validate(object)) {
            pool.offer(object);
        } else {
            expire(object);
        }
    }

    private void validatePool() {
        pool.removeIf(object -> {
            if (!validate(object)) {
                expire(object);
                return true;
            }
            return false;
        });
    }

    public void shutdown() {
        if (executorService != null) executorService.shutdown();
        pool.forEach(this::expire);
        pool.clear();
    }

    // abstract methods
    protected abstract T create();
    protected abstract boolean validate(T object);
    protected abstract void expire(T object);
}
