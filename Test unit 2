Write complete test case for this: @Configuration 1 usage 1 related problem

public class S3Config {

@Bean no usages

@Primary

public S3Client getS3Client() {

AttributeMap attributeMap = AttributeMap.builder()

.build();

final SdkHttpClient sdkHttpClient = new DefaultSdkHttpClientBuilder().buildWithDefaults(

attributeMap);

return S3Client.builder()

.region (Region.US_EAST_1)

.httpClient(sdkHttpClient)

.build();
}

package com.aflac.eib.extream.content.configuration;

import org.junit.jupiter.api.Test;
import software.amazon.awssdk.http.SdkHttpClient;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.s3.S3Client;

import static org.assertj.core.api.Assertions.assertThat;

class S3ConfigTest {

    @Test
    void getS3Client_shouldCreateValidS3Client() {

        // Arrange
        S3Config config = new S3Config();

        // Act
        S3Client client = config.getS3Client();

        // Assert
        assertThat(client)
                .as("S3Client should not be null")
                .isNotNull()
                .isInstanceOf(S3Client.class);

        // Validate region
        assertThat(client.serviceClientConfiguration().region())
                .as("Region should be US_EAST_1")
                .isEqualTo(Region.US_EAST_1);

        // Validate http client
        SdkHttpClient httpClient = client.serviceClientConfiguration().httpClient();

        assertThat(httpClient)
                .as("HttpClient should not be null")
                .isNotNull();

        assertThat(httpClient.getClass().getSimpleName())
                .as("HttpClient should be DefaultSdkHttpClient")
                .contains("DefaultSdkHttpClient");
    }
}


class S3ConfigTest {
@Test
void getS3Client_shouldCreateValidS3Client() {

// Arrange

S3Config config = new S3Config();

// Act

S3Client client config.getS3Client();

// Assert

assertNotNull(client, "S3Client should not be null");

// Prefer reading the configured region from the service configuration when

available

assertEquals(Region.US_EAST_1,

client.serviceClientConfiguration().region(),

"Region should be US_EAST_1");
SdkHttpClient httpClient client.serviceClientConfiguration().httpClient(); assertNotNull(httpClient, "HttpClient should not be null");

// Optionally, if you truly require a specific implementation name:

assertTrue(httpClient.getClass().getSimpleName().contains("DefaultSdkHttpClient"), "HttpClient should be DefaultSdkHttpClient or equivale
nt");











Write unit test cases for this codes: code 1: Configuration

@RequiredArgsConstructor

@Scope("singleton")

public class MQQueuePool extends ObjectPool<MQQueue> {

private final Environment env;

private static MQQueueManager mqQueueManager = null; 6 usages

private String mgPort = null; 3 usages

private String mgChannel = null; 3 usages

private String mqUsername = null; 4 usages

private String moPassword = null; 1 usage

private String mqName = null; 8 usages

private String mgManagerName = null; 3 usages

@PostConstruct 1 usage

private void initializeMQQueuePool() throws ApplicationException {

AppLogger.info(this.getClass(), msg: "Initializing MQ Queue Pool...");

try {

if (mqQueueManager == null || ImqQueueManager.isConnected()) {

String mqHost env.getProperty(key: "mqHostName", defaultValue: "upico.aflac.com");

this.mqPort env.getProperty(key: "mqPort", defaultValue: "1416");

this.mqChannel env.getProperty(key: "mqChannelName", defaultValue: "EIB.TO.PC01");

this.mqName env.getProperty(key: "mqQueueName", defaultValue: "AG.EOS.TO.EIB.IMAGE.DATA");this.mqManagerName = env.getProperty(key: "mqManagerName", defaultValue: "PC01");

this.mqUsername env.getProperty("mqUserName");

this.mqPassword env.getProperty("mqPassword");

}

MQEnvironment.hostname = mqHost;

MQEnvironment.port Integer.parseInt(this.mqPort);

MQEnvironment.channel = this.mqChannel;

AppLogger.info(this.getClass(), String.format(

"MQ Config loaded Manager: %s, Host: %s:%s, Channel: %s, Queue: %s, User: %s", mqManagerName, mqHost, mqPort, mqChannel, mqName, mqUsername, mqUsername != null ? mqUsername: "N/A"

));

mqQueueManager new MQQueueManager (mqManagerName);
}}
catch (MQException e) {

AppLogger.error(

this.getClass(), msg: "MQException while opening queue" mqName +

e

throw new ApplicationException(

"Failed to open MQ Queue: + mollame,

e

ExceptionType.TECHNICAL);}}Override

public MQQueue create() throws ApplicationException {

try {

if (mqQueueManager == null || !mqQueueManager.isConnected()) {

initializeMQQueuePool();

int openoptions MQC.MQOO INQUIRE + MQC.MQOO FAIL IF QUIESCING + MQC.MQOO INPUT SHARED;

MQQueue queue = mqQueueManager.accessQueue(mqName, openOptions);

AppLogger.info(this.getClass(),

msg: "MQQueuePool.create MQ Queue created successfully: " mqName);

return queue;
}
catch (Exception ex) {

AppLogger.error(

this.getClass(),

msg: "MQQueuePool.create Error creating MQ Queue: + mqName, ex

);

throw new ApplicationException(

"Unable to create MQ queue: mqName,

ex, ExceptionType.TECHNICAL);} finally {

AppLogger.info(this.getClass(), msg: "MQQueuePool.create - EXIT");

}

}

@Override 2 usages

public void expire (MQQueue queue) throws ApplicationException {

AppLogger.info(this.getClass(), msg: "MQQueuePool.expire - ENTER");

if (queue == null) {

}

AppLogger.warn(this.getClass(), msg: "MQQueuePool.expire Queue is null, nothing to close");

AppLogger.info(this.getClass(), msg: "MQQueuePool.expire - EXIT");

return;}try {

if (queue.isopen()) {

queue.close();

}

}

catch (Exception ex) {

AppLogger.error(this.getClass(), msg: "MQQueuePool.expire Error closing MQ Queue", ex);

throw new ApplicationException( "Failed to close MQ Queue", ex, ExceptionType.TECHNICAL

);

}

finally {

AppLogger.info(this.getClass(), msg: "MQQueuePool.expire EXIT");

}

}

@Override

public boolean validate(MQQueue queue) {

AppLogger.info(this.getClass(), msg: "MQQueuePool.validate - ENTER");try {

if (queue == null) {

AppLogger.warn(this.getClass(), msg: "MQQueuePool.validate Queue is null");

return false;

}

boolean isopen queue.isopen();

AppLogger.info(

); this.getClass(), msg: "MQQueuePool.validate Queue validation result: + isopen

return isopen;

} catch (Exception ex) {

AppLogger.error(this.getClass(), msg: "MQQueuePool.validate Exception during validation", ex); return false;

} finally {

}

AppLogger.info(this.getClass(), msg: "MQQueuePool.validate EXIT");

}}} , CODE 2: public abstract class ObjectPool<T> { 1 usage 1 inheritor

protected long expirationTime; 2 usages

private Hashtable<T, Long> locked, unlocked: 4 usages.

protected abstract T create() throws ApplicationException; 1 implementation

protected abstract boolean validate(To); 1 implementation

protected abstract void expire(To) throws ApplicationException; 2 usages 1 implementation

public ObjectPool() { no usages

expirationTime = 60008;

Locked = new Hashtable<T, Long>();

unlocked = new Hashtable<T, Long>();

}t = null;

} else {

if (validate(t)) {

unlocked.remove(t);

Locked.put(t, now);

return (t); I

} else {

// object failed validation

unlocked.remove(t);

expire(t);

t = null;

}

}

}

}

public synchronized T checkout() throws ApplicationException { no usages

Long now System.currentTimeMillis();

Tt;

if (unlocked.size() > 0) {

Enumeration<T> e unlocked.keys();

while (e.hasMoreElements()) {

te.nextElement();

if ((now unlocked.get(t)) > expirationTime) {

// object has expired

unlocked.remove(t);

expire(t);/ no objects available, create a new one

t = create();

locked.put(t, now);

return (t); }
public synchronized void checkIn(Tt) { no usages

Locked.remove(t);

unlocked.put(t, System.currentTimeMillis());

}












package com.aflac.eib.extream.content.mq;

import com.aflac.eib.extream.content.exception.ApplicationException;
import com.ibm.mq.*;
import org.junit.jupiter.api.*;
import org.mockito.*;
import org.springframework.core.env.Environment;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

class MQQueuePoolTest {

    @Mock
    private Environment env;

    @Mock
    private MQQueueManager mockManager;

    @Mock
    private MQQueue mockQueue;

    private MQQueuePool mqQueuePool;

    @BeforeEach
    void setup() {
        MockitoAnnotations.openMocks(this);

        when(env.getProperty(anyString(), anyString())).thenReturn("dummy");
        when(env.getProperty("mqUserName")).thenReturn("user1");
        when(env.getProperty("mqPassword")).thenReturn("pass1");

        mqQueuePool = Mockito.spy(new MQQueuePool(env));
    }

    // --------------------------
    // 1. Initialization Success
    // --------------------------
    @Test
    void initializeMQQueuePool_success() throws Exception {

        doReturn(mockManager).when(mqQueuePool).createMQManager(any());

        mqQueuePool.initializeMQQueuePool();

        assertNotNull(mqQueuePool);
        verify(env, atLeastOnce()).getProperty(anyString(), anyString());
    }

    // --------------------------
    // 2. Initialization Failure
    // --------------------------
    @Test
    void initializeMQQueuePool_mqException() throws Exception {

        doThrow(new MQException("Q", 2033, "failed"))
                .when(mqQueuePool).createMQManager(any());

        assertThrows(ApplicationException.class,
                () -> mqQueuePool.initializeMQQueuePool());
    }

    // --------------------------
    // 3. Create Queue Successfully
    // --------------------------
    @Test
    void create_success() throws Exception {

        doNothing().when(mqQueuePool).initializeMQQueuePool();

        doReturn(true).when(mockManager).isConnected();
        MQQueuePool.mqQueueManager = mockManager;

        when(mockManager.accessQueue(anyString(), anyInt())).thenReturn(mockQueue);

        MQQueue result = mqQueuePool.create();

        assertNotNull(result);
        verify(mockManager).accessQueue(anyString(), anyInt());
    }

    // --------------------------
    // 4. Create Queue Failure
    // --------------------------
    @Test
    void create_failure() throws Exception {

        doNothing().when(mqQueuePool).initializeMQQueuePool();
        MQQueuePool.mqQueueManager = mockManager;

        when(mockManager.accessQueue(anyString(), anyInt()))
                .thenThrow(new MQException("Q", 2033, "open fail"));

        assertThrows(ApplicationException.class, () -> mqQueuePool.create());
    }

    // --------------------------
    // 5. Expire - Null Queue
    // --------------------------
    @Test
    void expire_nullQueue() throws Exception {
        mqQueuePool.expire(null);
    }

    // --------------------------
    // 6. Expire - Open Queue
    // --------------------------
    @Test
    void expire_openQueue() throws Exception {

        when(mockQueue.isOpen()).thenReturn(true);

        mqQueuePool.expire(mockQueue);

        verify(mockQueue).close();
    }

    // --------------------------
    // 7. Expire - Exception
    // --------------------------
    @Test
    void expire_closeFailure() throws Exception {

        when(mockQueue.isOpen()).thenReturn(true);
        doThrow(new MQException("Q", 2033, "close fail")).when(mockQueue).close();

        assertThrows(ApplicationException.class,
                () -> mqQueuePool.expire(mockQueue));
    }

    // --------------------------
    // 8. Validate null
    // --------------------------
    @Test
    void validate_null() {
        assertFalse(mqQueuePool.validate(null));
    }

    // --------------------------
    // 9. Validate open
    // --------------------------
    @Test
    void validate_openQueue() throws Exception {

        when(mockQueue.isOpen()).thenReturn(true);
        assertTrue(mqQueuePool.validate(mockQueue));
    }

    // --------------------------
    // 10. Validate closed
    // --------------------------
    @Test
    void validate_closedQueue() throws Exception {

        when(mockQueue.isOpen()).thenReturn(false);
        assertFalse(mqQueuePool.validate(mockQueue));
    }
}










class TestObjectPool extends ObjectPool<StringBuilder> {

    @Override
    protected StringBuilder create() {
        return new StringBuilder();
    }

    @Override
    protected boolean validate(StringBuilder obj) {
        return obj.length() >= 0; // always valid
    }

    @Override
    protected void expire(StringBuilder obj) {
        // do nothing
    }
}


import org.junit.jupiter.api.*;

import static org.junit.jupiter.api.Assertions.*;

class ObjectPoolTest {

    private TestObjectPool pool;

    @BeforeEach
    void setup() {
        pool = new TestObjectPool();
    }

    // --------------------------
    // 1. Checkout first object
    // --------------------------
    @Test
    void checkout_createsNewObject() throws Exception {
        StringBuilder sb = pool.checkout();
        assertNotNull(sb);
    }

    // --------------------------
    // 2. CheckIn then Checkout
    // --------------------------
    @Test
    void checkInThenCheckout_reusesObject() throws Exception {

        StringBuilder obj = pool.checkout();
        pool.checkIn(obj);

        StringBuilder again = pool.checkout();
        assertSame(obj, again);
    }

    // --------------------------
    // 3. Expired object replaced
    // --------------------------
    @Test
    void checkout_replacesExpiredObjects() throws Exception {

        StringBuilder obj = pool.checkout();
        pool.checkIn(obj);

        // Force expiration
        Thread.sleep(pool.expirationTime + 10);

        StringBuilder newObj = pool.checkout();

        assertNotSame(obj, newObj);
    }

    // --------------------------
    // 4. Validate failure removes object
    // --------------------------
    @Test
    void checkout_invalidObject_isRemoved() throws Exception {

        TestObjectPool invalidPool = new TestObjectPool() {
            @Override
            protected boolean validate(StringBuilder obj) {
                return false; // always invalid
            }
        };

        StringBuilder sb = invalidPool.checkout();
        invalidPool.checkIn(sb);

        StringBuilder next = invalidPool.checkout();
        assertNotSame(sb, next); // must create new one
    }
}












import com.aflac.eib.extream.content.exception.ApplicationException;
import com.ibm.mq.MQEnvironment;
import com.ibm.mq.MQException;
import com.ibm.mq.MQQueue;
import com.ibm.mq.MQQueueManager;
import org.junit.jupiter.api.*;
import org.mockito.MockedConstruction;
import org.mockito.Mockito;
import org.springframework.core.env.Environment;

import java.lang.reflect.Field;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

class MQQueuePoolTest {

    private Environment env;
    private MQQueuePool pool;

    @BeforeEach
    void setup() throws Exception {

        env = mock(Environment.class);

        when(env.getProperty("mqHostName", "upico.aflac.com")).thenReturn("host1");
        when(env.getProperty("mqPort", "1416")).thenReturn("1417");
        when(env.getProperty("mqChannelName", "EIB.TO.PC01")).thenReturn("CH.A");
        when(env.getProperty("mqQueueName", "AG.EOS.TO.EIB.IMAGE.DATA")).thenReturn("Q1");
        when(env.getProperty("mqManagerName", "PC01")).thenReturn("QM1");
        when(env.getProperty("mqUserName")).thenReturn("user1");
        when(env.getProperty("mqPassword")).thenReturn("pass1");

        pool = new MQQueuePool(env);

        // Reset static mqQueueManager
        Field f = MQQueuePool.class.getDeclaredField("mqQueueManager");
        f.setAccessible(true);
        f.set(null, null);
    }

    @AfterEach
    void tearDown() throws Exception {
        Field f = MQQueuePool.class.getDeclaredField("mqQueueManager");
        f.setAccessible(true);
        f.set(null, null);
    }

    @Test
    void initialize_shouldSetMQEnvironment_andCreateManager_whenNotConnected() throws Exception {

        try (MockedConstruction<MQQueueManager> cons =
                     Mockito.mockConstruction(MQQueueManager.class, (mock, ctx) -> {
                         when(mock.isConnected()).thenReturn(true);
                     })) {

            MQQueueManager managerMock =
                    cons.constructed().isEmpty() ? null : cons.constructed().get(0);

            MQQueue queueMock = mock(MQQueue.class);

            if (managerMock != null) {
                when(managerMock.accessQueue(eq("Q1"), anyInt())).thenReturn(queueMock);
            }

            MQQueue q = pool.create();

            assertNotNull(q, "Queue should be returned from create()");
            assertEquals("host1", MQEnvironment.hostname);
            assertEquals(1417, MQEnvironment.port);
            assertEquals("CH.A", MQEnvironment.channel);

            if (managerMock != null) {
                verify(managerMock, times(1)).accessQueue(eq("Q1"), anyInt());
            }
        }
    }

    @Test
    void create_shouldThrowApplicationException_whenMQExceptionOccurs() throws Exception {

        try (MockedConstruction<MQQueueManager> cons =
                     Mockito.mockConstruction(MQQueueManager.class, (mock, ctx) -> {
                         when(mock.isConnected()).thenReturn(false);
                         when(mock.accessQueue(anyString(), anyInt()))
                                 .thenThrow(new MQException(2, 2009, "ConnFail"));
                     })) {

            Exception ex = assertThrows(ApplicationException.class, () -> pool.create());
            assertTrue(
                    ex.getMessage().contains("Unable to create MQ queue")
                            || ex.getMessage().contains("Failed"),
                    "Should wrap MQException in ApplicationException"
            );
        }
    }

    @Test
    void expire_shouldCloseQueue_whenOpen() throws Exception {

        MQQueue q = mock(MQQueue.class);
        when(q.isOpen()).thenReturn(true);

        pool.expire(q);

        verify(q, times(1)).close();
    }

    @Test
    void expire_shouldDoNothing_whenQueueNull() {
        assertDoesNotThrow(() -> pool.expire(null));
    }

    @Test
    void expire_shouldNotClose_whenNotOpen() throws Exception {

        MQQueue q = mock(MQQueue.class);
        when(q.isOpen()).thenReturn(false);

        pool.expire(q);

        verify(q, never()).close();
    }

    @Test
    void validate_shouldReturnFalse_whenNull() {
        assertFalse(pool.validate(null));
    }

    @Test
    void validate_shouldReturnTrue_whenOpen() throws Exception {

        MQQueue q = mock(MQQueue.class);
        when(q.isOpen()).thenReturn(true);

        assertTrue(pool.validate(q));
    }

    @Test
    void validate_shouldReturnFalse_whenClosedOrException() throws Exception {

        MQQueue qClosed = mock(MQQueue.class);
        when(qClosed.isOpen()).thenReturn(false);

        MQQueue qThrows = mock(MQQueue.class);
        when(qThrows.isOpen()).thenThrow(new RuntimeException("err"));

        assertFalse(pool.validate(qClosed));
        assertFalse(pool.validate(qThrows));
    }

    @Test
    void objectPool_integration_checkout_checkIn_flow() throws Exception {

        MQQueue queueMock = mock(MQQueue.class);

        try (MockedConstruction<MQQueueManager> cons =
                     Mockito.mockConstruction(MQQueueManager.class, (mock, ctx) -> {
                         when(mock.isConnected()).thenReturn(true);
                         when(mock.accessQueue(eq("Q1"), anyInt())).thenReturn(queueMock);
                     })) {

            MQQueue q1 = pool.checkout();
            assertSame(queueMock, q1);

            pool.checkIn(q1);

            pool.expirationTime = 10_000L;

            MQQueue q2 = pool.checkout();
            assertSame(q1, q2, "Should reuse unlocked queue if still valid");
        }
    }
}
